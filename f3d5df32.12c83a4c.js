(window.webpackJsonp=window.webpackJsonp||[]).push([[724],{781:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return u}));var a=t(2),r=t(6),i=(t(0),t(827)),s={title:"Make a Purchase",sidebar_label:"Make a Purchase"},o={unversionedId:"inappbilling/make-a-purchase",id:"inappbilling/make-a-purchase",isDocsHomePage:!1,title:"Make a Purchase",description:"Finally we reach the most important process in this extension, making a purchase.",source:"@site/docs/inappbilling/make-a-purchase.md",slug:"/inappbilling/make-a-purchase",permalink:"/docs/inappbilling/make-a-purchase",version:"current",sidebar_label:"Make a Purchase",sidebar:"inappbilling",previous:{title:"Products",permalink:"/docs/inappbilling/products"},next:{title:"Pending Purchases",permalink:"/docs/inappbilling/pending-purchases"}},c=[{value:"Finishing Purchases",id:"finishing-purchases",children:[{value:"Apple In-App Purchases",id:"apple-in-app-purchases",children:[]},{value:"Google Play Billing",id:"google-play-billing",children:[]}]},{value:"Example",id:"example",children:[]},{value:"Handling User Cancellations",id:"handling-user-cancellations",children:[]},{value:"Deferred Purchases",id:"deferred-purchases",children:[]}],l={rightToc:c};function u(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Finally we reach the most important process in this extension, making a purchase. "),Object(i.b)("p",null,'Making a purchase requires making a request to initiate the purchase and then "finishing the purchase" to\nfinalise the purchase and remove it from any internal queues.'),Object(i.b)("p",null,"Firstly create a ",Object(i.b)("inlineCode",{parentName:"p"},"PurchaseRequest")," object and set the ",Object(i.b)("inlineCode",{parentName:"p"},"productId")," and ",Object(i.b)("inlineCode",{parentName:"p"},"quantity")," you wish to purchase.\nThen pass this object to the ",Object(i.b)("inlineCode",{parentName:"p"},"makePurchase")," function.\nThis will initiate the purchase flow, most likely leaving your application and taking the user to the store interface."),Object(i.b)("p",null,"As the state of the purchase transaction changes you will be notified through the ",Object(i.b)("inlineCode",{parentName:"p"},"PurchaseEvent.PURCHASES_UPDATED")," event."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Note: We have deprecated all of the old ",Object(i.b)("inlineCode",{parentName:"p"},"PurchaseEvent"),"'s such as ",Object(i.b)("inlineCode",{parentName:"p"},"PURCHASE_SUCCESS")," in favour\nof a processing queue through the ",Object(i.b)("inlineCode",{parentName:"p"},"PURCHASES_UPDATED")," event."),Object(i.b)("p",{parentName:"blockquote"},"If you use any of the old events they will still work in the near future however we\nsuggest you migrate to the ",Object(i.b)("inlineCode",{parentName:"p"},"PURCHASES_UPDATED")," event to better handle purchase transaction states.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-actionscript"}),"InAppBilling.service.addEventListener( PurchaseEvent.PURCHASES_UPDATED, purchases_updatedHandler );\nInAppBilling.service.addEventListener( PurchaseEvent.PURCHASE_FAILED, purchase_failedHandler );\n\nvar request:PurchaseRequest = new PurchaseRequest();\nrequest.productId = productId;\nrequest.quantity = 1;\n\nvar success:Boolean = InAppBilling.service.makePurchase( request );\n")),Object(i.b)("p",null,"It is also important that you listen for the ",Object(i.b)("inlineCode",{parentName:"p"},"PURCHASE_FAILED")," event. This will be dispatched\nin situations where the purchase could not be attempted due to various reasons. You should\nrefer to the error code and message in the event to determine if it can be resolved."),Object(i.b)("p",null,"One of the most common situations that this will occur on is when the product is already owned\nby the user on Android. This case you should check for the ",Object(i.b)("inlineCode",{parentName:"p"},"ITEM_ALREADY_OWNED")," error code and\nthen load the purchases to retrieve the purchase."),Object(i.b)("p",null,"See the section on ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"get-purchases"}),"Get Purchases")," for more information on this process of retrieving purchases."),Object(i.b)("hr",null),Object(i.b)("h2",{id:"finishing-purchases"},"Finishing Purchases"),Object(i.b)("p",null,"As a rule it is important that you call ",Object(i.b)("inlineCode",{parentName:"p"},"finishPurchase()")," when you have completed the purchase\nand either handled the error or deployed the product to the user's inventory."),Object(i.b)("p",null,"If you don't call ",Object(i.b)("inlineCode",{parentName:"p"},"finishPurchase()")," then the next time the user opens the application and\nyou call ",Object(i.b)("inlineCode",{parentName:"p"},"setup()")," you will get notified again of the purchase as the system believes it to\nstill be pending. In some circumstances, failing to finish a purchase may result in the purchase\nbeing cancelled and the user refunded."),Object(i.b)("p",null,"Once complete the extension will dispatch the ",Object(i.b)("inlineCode",{parentName:"p"},"FINISH_SUCCESS")," event or if an error occurred then the ",Object(i.b)("inlineCode",{parentName:"p"},"FINISH_FAILED")," event will be dispatched:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-actionscript"}),'InAppBilling.service.addEventListener( InAppBillingEvent.FINISH_SUCCESS, successHandler );\nInAppBilling.service.addEventListener( InAppBillingEvent.FINISH_FAILED, failedHandler );\n\n\nfunction successHandler( event:InAppBillingEvent ):void\n{\n    trace( "finish purchase complete" );\n}\n\nfunction failedHandler( event:InAppBillingEvent ):void\n{\n    trace( "finish failed: ["+event.errorCode+"]" + event.message );\n}\n')),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"You must call ",Object(i.b)("inlineCode",{parentName:"p"},"finishPurchase")," and confirm by receiving the ",Object(i.b)("inlineCode",{parentName:"p"},"FINISH_SUCCESS")," event\nbefore attempting any other operation such as consuming the purchase. "),Object(i.b)("p",{parentName:"blockquote"},"The purchase is still in a pending state and not considered delivered to the user until you do. ")),Object(i.b)("h3",{id:"apple-in-app-purchases"},"Apple In-App Purchases"),Object(i.b)("p",null,"With Apple's In-App Purchases ",Object(i.b)("inlineCode",{parentName:"p"},"finishPurchase()")," will remove the purchase from the transaction queue,\nand inform Apple that you have delivered (and potentially verified) the purchase."),Object(i.b)("p",null,"On iOS you most often use this process to verify the transaction with your server, to verify whether you should deliver the product before calling ",Object(i.b)("inlineCode",{parentName:"p"},"finishPurchase()")," and the purchase information is removed from the queue."),Object(i.b)("h3",{id:"google-play-billing"},"Google Play Billing"),Object(i.b)("p",null,"With Google Play Billing the call to ",Object(i.b)("inlineCode",{parentName:"p"},"finishPurchase()")," performs the acknowledgement of the purchase.\nPurchases that aren't acknowledged will be returned by the ",Object(i.b)("inlineCode",{parentName:"p"},"getPendingPurchases()")," method and ",Object(i.b)("strong",{parentName:"p"},"may be refunded if you do not acknowledge them"),"."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Google Play supports purchasing products from inside of your app (in-app) or outside of your app (out-of-app). In order for Google Play to ensure a consistent purchase experience regardless of where the user purchases your product, you must acknowledge all purchases received through the Google Play Billing Library as soon as possible after granting entitlement to the user. If you do not acknowledge a purchase within three days, the user automatically receives a refund, and Google Play revokes the purchase. ")),Object(i.b)("p",null,"Note: ",Object(i.b)("em",{parentName:"p"},"Previously you may have attached a developer payload at this point. This is no longer supported and has been removed by Google in the Play Billing library v3.0.")," Instead consider using an obfuscated ",Object(i.b)("inlineCode",{parentName:"p"},"applicationUsername")," on your purchase request which will now get returned with a ",Object(i.b)("inlineCode",{parentName:"p"},"Purchase")," through Google Play Billing."),Object(i.b)("hr",null),Object(i.b)("h2",{id:"example"},"Example"),Object(i.b)("p",null,"The simplest way to do this is to simply call this in the event handler, however you may wish to do this at a later time,\nfor example, if you wish to validate the purchase using the transaction receipt with your application server. "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-actionscript"}),'// The service must be setup and a list of products retrieved.\n\nInAppBilling.service.addEventListener( PurchaseEvent.PURCHASES_UPDATED, purchases_updatedHandler );\nInAppBilling.service.addEventListener( PurchaseEvent.PURCHASE_FAILED, purchase_failedHandler );\nInAppBilling.service.addEventListener( InAppBillingEvent.FINISH_SUCCESS, finishPurchase_successHandler );\nInAppBilling.service.addEventListener( InAppBillingEvent.FINISH_FAILED, finishPurchase_failedHandler );\n\n\nvar request:PurchaseRequest = new PurchaseRequest();\nrequest.productId = productId;\nrequest.quantity = 1;\n\nvar success:Boolean = InAppBilling.service.makePurchase( request );\n\ntrace( "makePurchase( "+productId+" ) = " + success );\n\n\n\n//\n//  PURCHASE HANDLER\n//\n\nfunction purchases_updatedHandler( event:PurchaseEvent ):void\n{\n    for each (var purchase:Purchase in event.data)\n    {\n        switch (purchase.transactionState)\n        {\n            // These transactions are in progress, so don\'t finish them unless you don\'t want them to complete\n            case Purchase.STATE_PURCHASING:\n            case Purchase.STATE_DEFERRED:\n                break;\n            \n            // The purchased state should finished after you have delivered the product if applicable\n            case Purchase.STATE_PURCHASED:\n            {\n                trace( "purchase success" );\n                \n                //\n                // If you wish you can add the purchase to your inventory\n                // and finish the purchase here\n                addPurchaseToInventory( purchase );\n                InAppBilling.service.finishPurchase( purchase );\n                \n                //\n                // Alternatively hold onto this purchase so we can call\n                // finish when you\'ve delivered the product\n                //\n                // You would do this if you are validating the purchase on a server or\n                // other operation that is required to complete before the product is delivered\n                //_purchases.push( purchase );\n                break;\n            }\n            \n            \n            // For all other states you should handle appropriately and call finish purchase \n            case Purchase.STATE_FAILED:\n            case Purchase.STATE_REFUNDED:\n            case Purchase.STATE_RESTORED:\n            case Purchase.STATE_REMOVED:\n            case Purchase.STATE_CANCELLED:\n            case Purchase.STATE_NOTALLOWED:\n                InAppBilling.service.finishPurchase( purchase );\n                break;\n        }\n    }\n}\n\nfunction purchase_failedHandler( event:PurchaseEvent ):void\n{\n    // This transaction failed so you should notify your user and finish the purchase\n    log( "purchase failed [" + event.errorCode + "] :: "+ event.message );\n    if (event.data && event.data.length > 0)\n    {\n        InAppBilling.service.finishPurchase( event.data[0] );\n    }\n    \n    //\n    // Android may return this code if the item is already owned\n    //\n    if (event.errorCode == ErrorCodes.ITEM_ALREADY_OWNED)\n    {\n        // You should use getPurchases() to retrieve the users purchases\n        // and then add them as missing from their current inventory\n        InAppBilling.service.getPurchases();\n    }\n    \n}\n\nfunction finishPurchase_successHandler( event:InAppBillingEvent ):void\n{\n    trace( "finish purchase complete" );\n}\n\nfunction finishPurchase_failedHandler( event:InAppBillingEvent ):void\n{\n    trace( "finish failed: ["+event.errorCode+"]" + event.message );\n}\n\n')),Object(i.b)("hr",null),Object(i.b)("h2",{id:"handling-user-cancellations"},"Handling User Cancellations"),Object(i.b)("p",null,"When a user cancels a purchase there are two avenues that you'll need to handle, due to the different ways that Android and iOS handle these cases."),Object(i.b)("p",null,"On iOS there will be a ",Object(i.b)("inlineCode",{parentName:"p"},"Purchase")," initiated immediately so when the user cancels the purchase you will receive a ",Object(i.b)("inlineCode",{parentName:"p"},"PurchaseEvent.PURCHASES_UPDATED")," and the purchases transaction state will be set to ",Object(i.b)("inlineCode",{parentName:"p"},"Purchase.STATE_CANCELLED"),".\nYou will need to handle this case in your purchases updated handler and finish the purchase to remove it from the pending purchases queue."),Object(i.b)("p",null,"For example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-actionscript"}),"function purchases_updatedHandler( event:PurchaseEvent ):void\n{\n    for each (var purchase:Purchase in event.data)\n    {\n        switch (purchase.transactionState)\n        {\n            // Other states ... \n\n            case Purchase.STATE_CANCELLED:\n                // User Cancelled\n                InAppBilling.service.finishPurchase( purchase );\n                break;\n        }\n    }\n} \n")),Object(i.b)("p",null,"On Android the purchase is not initiated so there is no ",Object(i.b)("inlineCode",{parentName:"p"},"Purchase")," to return, hence you will not receive a purchases updated event but instead a ",Object(i.b)("inlineCode",{parentName:"p"},"PurchaseEvent.PURCHASE_FAILED")," event will be dispatched. The error code on the failed event will be set to ",Object(i.b)("inlineCode",{parentName:"p"},"ErrorCodes.USER_CANCELLED")," or ",Object(i.b)("inlineCode",{parentName:"p"},"ErrorCodes.RESPONSE_CANCELLED")," so you can use this code to process the user cancellation. As this purchase was not initiated it does not need to be finished and will not appear in the pending purchases queue."),Object(i.b)("p",null,"For example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-actionscript"}),"function purchase_failedHandler( event:PurchaseEvent ):void\n{\n    switch (event.errorCode)\n    {\n        // Other error codes...\n\n        case ErrorCodes.RESPONSE_CANCELLED:\n        case ErrorCodes.USER_CANCELLED:\n            // User cancelled\n            break;\n    }\n}\n")),Object(i.b)("p",null,"You should ensure you handle both these cases in your application if you wish to handle user cancellations. "),Object(i.b)("hr",null),Object(i.b)("h2",{id:"deferred-purchases"},"Deferred Purchases"),Object(i.b)("p",null,"Of special note are deferred purchases. Deferred purchases are purchases that are in progress and require further user action external to your application, such as a parental approval or payment in cash at a physical store."),Object(i.b)("p",null,"With Apple's In-App Purhcases:"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"The transaction is in the queue, but its final status is pending external action such as Ask to Buy. Update your UI to show the deferred state, and wait for another callback that indicates the final status.")),Object(i.b)("p",null,'With Google Play Billing the deferred state is equivalent to the "PENDING" purchase state where additional action is required before granting entitlement.'),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"For example, a user might choose to purchase your in-app product at a physical store using cash. This means that the transaction is completed outside of your app. In this scenario, you should grant entitlement only after the user has completed the transaction.")),Object(i.b)("p",null,"In order to correctly handle deferred purchases you should ",Object(i.b)("strong",{parentName:"p"},"not finish the purchase"),", but leave it in the queue until the user completes the external action."),Object(i.b)("p",null,'Once the user completes the action you will receive a purchases updated event and should process the purchase at that point.\nIt is important however if you display some "purchase in progress" UI during the making a purchase process that you close that once you receive this event. You may wish to display a message appropriate to your application indicating that they need to take action outside the app.'),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-actionscript"}),'function purchases_updatedHandler( event:PurchaseEvent ):void\n{\n    for each (var purchase:Purchase in event.data)\n    {\n        switch (purchase.transactionState)\n        {\n            // Do nothing with the deferred purchase. Ensure you close any "purchase in progress" UI \n            case Purchase.STATE_DEFERRED:\n                break;\n\n...\n')))}u.isMDXComponent=!0},827:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return b}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),u=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},d=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(t),d=a,b=p["".concat(s,".").concat(d)]||p[d]||h[d]||i;return t?r.a.createElement(b,o(o({ref:n},l),{},{components:t})):r.a.createElement(b,o({ref:n},l))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=d;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var l=2;l<i;l++)s[l]=t[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);