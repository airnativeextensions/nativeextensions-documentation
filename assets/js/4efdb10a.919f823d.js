"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[98991],{3905:function(e,t,a){a.d(t,{Zo:function(){return s},kt:function(){return d}});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),l=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},s=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=l(a),d=n,f=u["".concat(c,".").concat(d)]||u[d]||m[d]||i;return a?r.createElement(f,o(o({ref:t},s),{},{components:a})):r.createElement(f,o({ref:t},s))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=u;var p={};for(var c in t)hasOwnProperty.call(t,c)&&(p[c]=t[c]);p.originalType=e,p.mdxType="string"==typeof e?e:n,o[1]=p;for(var l=2;l<i;l++)o[l]=a[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},75615:function(e,t,a){a.r(t),a.d(t,{assets:function(){return s},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return p},metadata:function(){return l},toc:function(){return m}});var r=a(83117),n=a(80102),i=(a(67294),a(3905)),o=["components"],p={title:"Preview Frames",sidebar_label:"Preview Frames"},c=void 0,l={unversionedId:"camera/preview-frames",id:"camera/preview-frames",title:"Preview Frames",description:"Preview Frames",source:"@site/docs/camera/preview-frames.md",sourceDirName:"camera",slug:"/camera/preview-frames",permalink:"/docs/camera/preview-frames",draft:!1,tags:[],version:"current",frontMatter:{title:"Preview Frames",sidebar_label:"Preview Frames"},sidebar:"camera",previous:{title:"Connecting",permalink:"/docs/camera/connecting"},next:{title:"Capturing Images",permalink:"/docs/camera/capturing-images"}},s={},m=[{value:"Preview Frames",id:"preview-frames",level:2}],u={toc:m};function d(e){var t=e.components,a=(0,n.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"preview-frames"},"Preview Frames"),(0,i.kt)("p",null,"Once you have connected to a camera device you are most likely going to want to show a\npreview to your users. "),(0,i.kt)("p",null,"Preview frames are provided through the ",(0,i.kt)("inlineCode",{parentName:"p"},"CameraEvent.VIDEO_FRAME")," event. This is dispacted\nfrom a camera device whenever a preview frame is available. The event indicates that bitmap\ndata representing the current view through the camera device is available."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},"device.addEventListener( CameraEvent.VIDEO_FRAME, camera_videoFrameHandler );\n")),(0,i.kt)("p",null,"When you receive the event you can then query the extension for the frame buffer using the\n",(0,i.kt)("inlineCode",{parentName:"p"},"getFrameBuffer")," function. This function takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"ByteArray")," which will be filled with the\nbitmap data of the preview frame. "),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"ByteArray")," is used to ensure we can transfer the data from the native side to your AS3\nquickly, attempting to keep the frame rate of your preview frame as high as possible. ")),(0,i.kt)("p",null,"To render the data you should create an appropriately sized ",(0,i.kt)("inlineCode",{parentName:"p"},"BitmapData")," object and use the\n",(0,i.kt)("inlineCode",{parentName:"p"},"setPixels")," to update the bitmap data from the ",(0,i.kt)("inlineCode",{parentName:"p"},"ByteArray"),"."),(0,i.kt)("p",null,"Firstly lets create the bitmap data:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},'var _previewBitmapData:BitmapData = new BitmapData( 1, 1, false );\nvar _previewBitmapRect:Rectangle = new Rectangle( 0, 0, 1, 1 );\n\n//\n//  Check we have an appropriately sized bitmapdata and texture\n//      Recreate if not\nif (_previewBitmapData.width != device.width || _previewBitmapData.height != device.height)\n{\n    trace( "resizing to: (" + device.width +", "+ device.height +")" );\n    _previewBitmapData.dispose();\n    \n    _previewBitmapData = new BitmapData( device.width, device.height, false );\n    \n    _previewBitmapRect = new Rectangle( 0, 0, _previewBitmapData.width, _previewBitmapData.height );\n}\n')),(0,i.kt)("p",null,"Then in our event handler we update from the frame buffer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},"private function camera_videoFrameHandler( event:CameraEvent ):void \n{\n    if (-1 != device.getFrameBuffer( _previewData ))\n    {\n        try\n        {\n            //\n            //  Update the bitmapdata and texture\n            _previewBitmapData.setPixels( _previewBitmapRect, _previewData );\n            \n            // For Starling 1.x\n            // flash.display3D.textures.Texture(_previewTexture.base).uploadFromBitmapData( _previewBitmapData );\n\n            // For Starling 2.x\n            flash.display3D.textures.RectangleTexture(_previewTexture.base).uploadFromBitmapData( _previewBitmapData );\n        }\n        catch (e:Error)\n        {\n            trace( e );\n        }\n        finally\n        {\n            _previewData.clear();\n            _lastFrameProcessed = frame;\n        }\n    }\n}\n")),(0,i.kt)("p",null,"We also suggest you rotate the container of your bitmap data to match the orientation of the\ncamera device. You should use the ",(0,i.kt)("inlineCode",{parentName:"p"},"device.info.orientation")," value to rotate appropriately."),(0,i.kt)("p",null,"See the example applications for demonstrations of this, and the following gists:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gist.github.com/marchbold/ce93ed72a5fb60db045e6168362d5508"},"Starling Camera Preview Example"))))}d.isMDXComponent=!0}}]);