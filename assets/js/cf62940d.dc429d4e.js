"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[49165],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},v=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(n),v=i,h=c["".concat(s,".").concat(v)]||c[v]||d[v]||l;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=v;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:i,r[1]=o;for(var u=2;u<l;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}v.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(67294),i=n(86010);const l={tabItem:"tabItem_Ymn6"};function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(l.tabItem,r),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>A});var a=n(87462),i=n(67294),l=n(86010),r=n(12466),o=n(16550),s=n(91980),u=n(67392),p=n(50012);function c(e){return function(e){var t,n;return null!=(t=null==(n=i.Children.map(e,(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:n.filter(Boolean))?t:[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:i}}=e;return{value:t,label:n,attributes:a,default:i}}))}function d(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=null!=t?t:c(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function v(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=n?n:null}({queryString:t,groupId:n});return[(0,s._X)(l),(0,i.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(a.location.search);t.set(l,e),a.replace({...a.location,search:t.toString()})}),[l,a])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,l=d(e),[r,o]=(0,i.useState)((()=>function(e){var t;let{defaultValue:n,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!v({value:n,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}const i=null!=(t=a.find((e=>e.default)))?t:a[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:t,tabValues:l}))),[s,u]=h({queryString:n,groupId:a}),[c,m]=function(e){let{groupId:t}=e;const n=function(e){return e?"docusaurus.tab."+e:null}(t),[a,l]=(0,p.Nk)(n);return[a,(0,i.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:a}),y=(()=>{const e=null!=s?s:c;return v({value:e,tabValues:l})?e:null})();(0,i.useLayoutEffect)((()=>{y&&o(y)}),[y]);return{selectedValue:r,selectValue:(0,i.useCallback)((e=>{if(!v({value:e,tabValues:l}))throw new Error("Can't select invalid tab value="+e);o(e),u(e),m(e)}),[u,m,l]),tabValues:l}}var y=n(72389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(e){let{className:t,block:n,selectedValue:o,selectValue:s,tabValues:u}=e;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.o5)(),d=e=>{const t=e.currentTarget,n=p.indexOf(t),a=u[n].value;a!==o&&(c(t),s(a))},v=e=>{var t;let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var a;const t=p.indexOf(e.currentTarget)+1;n=null!=(a=p[t])?a:p[0];break}case"ArrowLeft":{var i;const t=p.indexOf(e.currentTarget)-1;n=null!=(i=p[t])?i:p[p.length-1];break}}null==(t=n)||t.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:r}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>p.push(e),onKeyDown:v,onClick:d},r,{className:(0,l.Z)("tabs__item",f.tabItem,null==r?void 0:r.className,{"tabs__item--active":o===t})}),null!=n?n:t)})))}function b(e){let{lazy:t,children:n,selectedValue:a}=e;const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function k(e){const t=m(e);return i.createElement("div",{className:(0,l.Z)("tabs-container",f.tabList)},i.createElement(g,(0,a.Z)({},e,t)),i.createElement(b,(0,a.Z)({},e,t)))}function A(e){const t=(0,y.Z)();return i.createElement(k,(0,a.Z)({key:String(t)},e))}},31713:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>u,toc:()=>c});var a=n(87462),i=(n(67294),n(3905)),l=n(74866),r=n(85162);const o={title:"Setup Billing Service",sidebar_label:"Setup Billing Service"},s=void 0,u={unversionedId:"inappbilling/billing-service",id:"inappbilling/billing-service",title:"Setup Billing Service",description:"Billing Service",source:"@site/docs/inappbilling/billing-service.mdx",sourceDirName:"inappbilling",slug:"/inappbilling/billing-service",permalink:"/docs/inappbilling/billing-service",draft:!1,tags:[],version:"current",frontMatter:{title:"Setup Billing Service",sidebar_label:"Setup Billing Service"},sidebar:"inappbilling",previous:{title:"Testing",permalink:"/docs/inappbilling/samsung/testing"},next:{title:"Products",permalink:"/docs/inappbilling/products"}},p={},c=[{value:"Billing Service",id:"billing-service",level:2},{value:"Events",id:"events",level:2},{value:"Service Type",id:"service-type",level:2},{value:"Availability",id:"availability",level:2},{value:"Pending Purchases",id:"pending-purchases",level:2}],d={toc:c},v="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(v,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"billing-service"},"Billing Service"),(0,i.kt)("p",null,"Before starting here you should make sure you have already setup the service for your application\nas outlined in earlier sections.\nThis is where you would have added products to your application in the appropriate developer console."),(0,i.kt)("p",null,"The next step to using the functionality in this extension is to setup a billing (or purchasing) service.\nThis simply requires you to set the service you plan on using and calling ",(0,i.kt)("inlineCode",{parentName:"p"},"setup()")," with any service configuration required."),(0,i.kt)("p",null,"The following uses the default service for the current device and specifies the Google Play Billing Public License key:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},"var service:BillingService = new BillingService()\n    .setGooglePlayPublicKey( GOOGLE_PLAY_INAPP_BILLING_KEY );\n\nvar success:Boolean = InAppBilling.service.setup( service );\n")),(0,i.kt)("p",null,"This call performs a few things internally "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Initialises the billing service"),(0,i.kt)("li",{parentName:"ul"},"Initialises the purchase queue "),(0,i.kt)("li",{parentName:"ul"},"Adds appropriate native purchase handlers"),(0,i.kt)("li",{parentName:"ul"},"Checks the state of any pending purchases")),(0,i.kt)("p",null,"The return value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"setup()")," function indicates if the configured service type is supported on\nthe current device. This may return ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," if you have for example requests Apple In-App Purchases on\nan Android device. "),(0,i.kt)("p",null,"Once this is complete the ",(0,i.kt)("inlineCode",{parentName:"p"},"InAppBillingEvent.SETUP_SUCCESS")," event will be dispatched and the service\nis available for queries."),(0,i.kt)("p",null,"If an error occurred then the ",(0,i.kt)("inlineCode",{parentName:"p"},"InAppBillingEvent.SETUP_FAILURE")," event will be dispatched. This is a fatal\nevent and will stop any other functionality from working successfully. Generally this only occurs due\nto a misconfiguration and is to help you get an application working correctly however you should make\nsure that you handle the event appropriately."),(0,i.kt)("h2",{id:"events"},"Events"),(0,i.kt)(l.Z,{groupId:"framework",defaultValue:"air",values:[{label:"AIR",value:"air"},{label:"Unity",value:"unity"}],mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"air",mdxType:"TabItem"},"We suggest you listen to the following four events before calling setup:",(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBillingEvent.SETUP_SUCCESS"),": Dispatched when setup is successfully completed;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBillingEvent.SETUP_FAILURE"),": Dispatched when there was an error during setup;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PurchaseEvent.PURCHASES_UPDATED"),": Dispatched if there are pending purchases needing to be processed;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PurchaseRequestEvent.SHOULD_ADD_PURCHASE"),": Dispatched if the app was launched from an AppStore promotional purchase (see ",(0,i.kt)("a",{parentName:"li",href:"promotions"},"Promotions"),").")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},"InAppBilling.service.addEventListener( PurchaseEvent.PURCHASES_UPDATED, purchases_updatedHandler );\nInAppBilling.service.addEventListener( PurchaseRequestEvent.SHOULD_ADD_PURCHASE, purchaseRequest_shouldAddPurchaseHandler );\n                        \nInAppBilling.service.setup(\n        new BillingService()\n                .setGooglePlayPublicKey( GOOGLE_PLAY_INAPP_BILLING_KEY )\n);\n"))),(0,i.kt)(r.Z,{value:"unity",mdxType:"TabItem"},(0,i.kt)("p",null,"We suggest you listen to the following four events before calling setup:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBilling.Instance.Events.OnPurchasesUpdated"),": Dispatched if there are pending purchases needing to be processed;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBilling.Instance.Events.OnShouldAddPurchase"),": Dispatched if the app was launched from an AppStore promotional purchase (see ",(0,i.kt)("a",{parentName:"li",href:"promotions"},"Promotions"),");")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"InAppBilling.Instance.Events.OnPurchasesUpdated += OnPurchasesUpdated;\nInAppBilling.Instance.Events.OnShouldAddPurchase += OnShouldAddPurchase;\n\nInAppBilling.Instance.Setup(\n        new BillingService()\n            .SetGooglePlayPublicKey( GOOGLE_PLAY_INAPP_BILLING_KEY )\n);                \n")))),(0,i.kt)("h2",{id:"service-type"},"Service Type"),(0,i.kt)("p",null,"The billing service type will be automatically selected based on the default of the current device platform. However we suggest you specify the service type in your ",(0,i.kt)("inlineCode",{parentName:"p"},"BillingService")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"setServiceType()")," to specify a particular service:"),(0,i.kt)(l.Z,{groupId:"framework",defaultValue:"air",values:[{label:"AIR",value:"air"},{label:"Unity",value:"unity"}],mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"air",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},"var service:BillingService = new BillingService(  )\n    .setServiceType( InAppBillingServiceTypes.GOOGLE_PLAY_INAPP_BILLING )\n    .setGooglePlayPublicKey( GOOGLE_PLAY_INAPP_BILLING_KEY );\n\nvar success:Boolean = InAppBilling.service.setup( service );\n"))),(0,i.kt)(r.Z,{value:"unity",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var service = new BillingService()\n    .SetServiceType( InAppBillingServiceTypes.GOOGLE_PLAY_INAPP_BILLING )\n    .SetGooglePlayPublicKey( GOOGLE_PLAY_INAPP_BILLING_KEY );\nInAppBilling.Instance.Setup( service );\n")))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"You do not need to call ",(0,i.kt)("inlineCode",{parentName:"p"},"setServiceType()"),".\nIf you do not call it then the default for the current platform will be used,\ni.e. Apple InApp Purchases on iOS and Google's Play InApp Billing on Android."),(0,i.kt)("p",{parentName:"admonition"},"We suggest that you do specify a service type, particularly on Android where there are multiple stores involved.\nThis is so that you ensure you are utilising the correct store for your application, otherwise you may find that the extension incorrectly assumes you are using the default store on the device (eg Huawei AppGallery on a Huawei device), which may not be what you intend.")),(0,i.kt)("h2",{id:"availability"},"Availability"),(0,i.kt)("p",null,"Once you have completed setup it is important to check whether the user on the current device can make payments. There are certain factors that can limit the functionality which can have consequences for all product and purchasing functionality."),(0,i.kt)("p",null,"For example, the latest version of Play Billing is only supported with an updated version of the Play Store app. If an older version is on the user's device the billing api will not be available."),(0,i.kt)(l.Z,{groupId:"framework",defaultValue:"air",values:[{label:"AIR",value:"air"},{label:"Unity",value:"unity"}],mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"air",mdxType:"TabItem"},(0,i.kt)("p",null,"To check the status call the ",(0,i.kt)("inlineCode",{parentName:"p"},"checkAvailability()")," function and await the result. This function will dispatch an ",(0,i.kt)("inlineCode",{parentName:"p"},"AvailabilityEvent.COMPLETE")," event or call a callback function passed as the parameter to the function."),(0,i.kt)("p",null,"Callback:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},'InAppBilling.service.checkAvailability(\n        function ( availability:String ):void\n        {\n            trace( "availability = " + availability );\n        }\n);\n')),(0,i.kt)("p",null,"Event:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},'InAppBilling.service.addEventListener( AvailabilityEvent.COMPLETE, function( event:AvailabilityEvent ):void\n{\n    trace( "availability = " + event.availability );\n});\nInAppBilling.service.checkAvailability();\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"availability")," value will be one of the values defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"InAppBillingAvailability")," class:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBillingAvailability.AVAILABLE"),": Service is available for products and purchases;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBillingAvailability.NOT_AVAILABLE"),": Service is unavailable on the device;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBillingAvailability.STORE_UPGRADE_REQUIRED"),": An update is required to the store application for this service"))),(0,i.kt)(r.Z,{value:"unity",mdxType:"TabItem"},(0,i.kt)("p",null,"To check the status call the ",(0,i.kt)("inlineCode",{parentName:"p"},"CheckAvailability()")," function and await the result. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'InAppBilling.Instance.CheckAvailability(\n        (e) =>\n        {\n            Debug.Log( "availability = " + e.availability );\n        }\n);\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"e.availability")," value will be one of the values defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"InAppBillingAvailability")," class:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBillingAvailability.AVAILABLE"),": Service is available for products and purchases;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBillingAvailability.NOT_AVAILABLE"),": Service is unavailable on the device;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InAppBillingAvailability.STORE_UPGRADE_REQUIRED"),": An update is required to the store application for this service;")))),(0,i.kt)("p",null,"You should handle the response as required and inform your users if purchasing isn't available or steps to upgrade the store application."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"If you don't check for the availability you will find certain aspects of the extension will fail. For example, if a store upgrade is required you will likely get failed events from functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"getProducts()")," with the error code ",(0,i.kt)("inlineCode",{parentName:"p"},"FEATURE_NOT_SUPPORTED"),". "),(0,i.kt)("p",{parentName:"admonition"},"It is equally appropriate to handle those error events however we suggest an upfront approach using this function can provide a better user experience.")),(0,i.kt)("h2",{id:"pending-purchases"},"Pending Purchases"),(0,i.kt)(l.Z,{groupId:"framework",defaultValue:"air",values:[{label:"AIR",value:"air"},{label:"Unity",value:"unity"}],mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"air",mdxType:"TabItem"},(0,i.kt)("p",null,"Note that the pending purchases may not be available to you at the  ",(0,i.kt)("inlineCode",{parentName:"p"},"InAppBillingEvent.SETUP_SUCCESS")," event, as they may be updated after setup has completed.\nThis is particularly true on iOS/tvOS where the payment queue update (which populates the pending purchases) will occur a short time after setup succeeds."),(0,i.kt)("p",null,"This update will be indicated by a ",(0,i.kt)("inlineCode",{parentName:"p"},"PurchaseEvent.PURCHASES_UPDATED"),", indicating there are purchases to process.")),(0,i.kt)(r.Z,{value:"unity",mdxType:"TabItem"},(0,i.kt)("p",null,"Note that the pending purchases may not be available to you after setup is complete, as they may be updated after this point.\nThis is particularly true on iOS/tvOS where the payment queue update (which populates the pending purchases) will occur a short time after setup succeeds."),(0,i.kt)("p",null,"This update will be indicated by an ",(0,i.kt)("inlineCode",{parentName:"p"},"OnPurchasesUpdated")," event, indicating there are purchases to process."))))}h.isMDXComponent=!0}}]);