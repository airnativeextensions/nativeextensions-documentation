"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[10400],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var a=n(96540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}},60155:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"gameservices/turn-based-multiplayer---implementation","title":"Turn Based Multiplayer - Implementation","description":"Sections:","source":"@site/docs/gameservices/turn-based-multiplayer---implementation.md","sourceDirName":"gameservices","slug":"/gameservices/turn-based-multiplayer---implementation","permalink":"/docs/gameservices/turn-based-multiplayer---implementation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Turn Based Multiplayer - Implementation","sidebar_label":"Implementation"},"sidebar":"gameservices","previous":{"title":"Implementation Overview","permalink":"/docs/gameservices/turn-based-multiplayer---implementation-overview"},"next":{"title":"Invitations","permalink":"/docs/gameservices/turn-based-multiplayer---invitations"}}');var i=n(74848),s=n(28453);const r={title:"Turn Based Multiplayer - Implementation",sidebar_label:"Implementation"},c=void 0,l={},h=[{value:"Creating a match",id:"creating-a-match",level:2},{value:"Player Selection",id:"player-selection",level:3},{value:"Create Match",id:"create-match",level:3},{value:"Taking the first turn",id:"taking-the-first-turn",level:3},{value:"Loading Matches",id:"loading-matches",level:2},{value:"Match Data",id:"match-data",level:2},{value:"Taking Turns",id:"taking-turns",level:2},{value:"Match Updates",id:"match-updates",level:2},{value:"Leaving a Match",id:"leaving-a-match",level:2},{value:"Completing a Match",id:"completing-a-match",level:2}];function o(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Sections:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#creating-a-match",children:"Creating a Match"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#loading-matches",children:"Loading Matches"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#match-data",children:"Match Data"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#taking-turns",children:"Taking Turns"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#match-updates",children:"Match Updates"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#leaving-a-match",children:"Leaving a Match"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#completing-a-match",children:"Completing a Match"})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"creating-a-match",children:"Creating a match"}),"\n",(0,i.jsx)(t.h3,{id:"player-selection",children:"Player Selection"}),"\n",(0,i.jsxs)(t.p,{children:["The process of creating a match works slightly differently on the platforms however the\nbest cross-platform way to create a match is to first call ",(0,i.jsx)(t.code,{children:"displayCreateMatchUI"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"This will display some form of UI that will ask the user to select players to invite,\nand then end in a create match event."}),"\n",(0,i.jsxs)(t.p,{children:["This call allows a few options for you to guide how many players, minimum, maximum and\nwhether auto matching is allowed, through the ",(0,i.jsx)(t.code,{children:"PlayerSelectionOptions"})," class."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"var options:PlayerSelectionOptions = new PlayerSelectionOptions();\noptions.minPlayers = 1;\noptions.maxPlayers = 3;\noptions.allowAutomatch = false;\n\nGameServices.service.turnBasedMultiplayer.displayCreateMatchUI( options );\n"})}),"\n",(0,i.jsx)(t.p,{children:"This will then dispatch one of the following events:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMultiplayerEvent.CREATEMATCH_UI_SUCCESS"}),": Dispatched when the player selects oponents for the match"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMultiplayerEvent.CREATEMATCH_UI_ERROR"}),": Dispatched if there was an error during the create match UI"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMultiplayerEvent.CREATEMATCH_UI_CANCEL"}),": Dispatched when the player cancels the create match UI"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMatchEvent.CREATE_SUCCESS"}),": Dispatched when the match is created"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"GameServices.service.turnBasedMultiplayer.addEventListener( TurnBasedMultiplayerEvent.CREATEMATCH_UI_SUCCESS, createMatchUISuccessHandler );\nGameServices.service.turnBasedMultiplayer.addEventListener( TurnBasedMultiplayerEvent.CREATEMATCH_UI_CANCEL, createMatchUICancelHandler );\nGameServices.service.turnBasedMultiplayer.addEventListener( TurnBasedMultiplayerEvent.CREATEMATCH_UI_ERROR, createMatchUIErrorHandler );\n\nGameServices.service.turnBasedMultiplayer.addEventListener( TurnBasedMatchEvent.CREATE_SUCCESS, matchCreateHandler );\n"})}),"\n",(0,i.jsx)(t.h3,{id:"create-match",children:"Create Match"}),"\n",(0,i.jsx)(t.p,{children:"You can handle the cancel and errors as your application requires. The success event will contain\ninformation about the selected players and allow you to create a match:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:'function createMatchUISuccessHandler( event:TurnBasedMultiplayerEvent ):void\n{\n\t//\n\t//\tThis event is fired when the create match ui is completed and we need\n\t//\tto manually call create match.\n\t//\n\t//\tThis is not needed on GameCenter as you will immediately get a CREATE_SUCCESS  \n\t//\tevent.\n\t\n\tvar config:TurnBasedMatchConfig = event.data;\n\tmessage( " --- INVITED PLAYERS" );\n\tfor each (var id:String in config.invitedPlayers)\n\t\tmessage( " P: " + id );\n\tmessage( " --- " );\n\t\n\tGameServices.service.turnBasedMultiplayer.createMatch( config );\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Then when the match is created you will receive the ",(0,i.jsx)(t.code,{children:"TurnBasedMatchEvent.CREATE_SUCCESS"})," event\nwhich will contain the ",(0,i.jsx)(t.code,{children:"TurnBasedMatch"})," reference for the match:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"function matchCreateHandler( event:TurnBasedMatchEvent ):void \n{\n\t//\tYou should store the match for usage in your game\n\t// \tThis forms the main interface for turn based matches.\n\tvar match:TurnBasedMatch = event.match;\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["At this point it is good practice to initialise the ",(0,i.jsx)(t.code,{children:"match"})," with some initial game data.\nThe ",(0,i.jsx)(t.code,{children:"match"})," object contains a ",(0,i.jsx)(t.code,{children:"data"})," ByteArray that you use to store information about\nthe game state."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"// Use match.data to write some initial data state\n"})}),"\n",(0,i.jsx)(t.h3,{id:"taking-the-first-turn",children:"Taking the first turn"}),"\n",(0,i.jsxs)(t.p,{children:["Once you have created the match you can now have your player take their first turn\nexecuting your game play as you see fit. The result of the players actions should\nbe then written to the match data and then you should call ",(0,i.jsx)(t.code,{children:"takeTurn"})," specifying\nthe next participant. See Taking Turns for more information on using ",(0,i.jsx)(t.code,{children:"takeTurn"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"It is very important that your player takes the first turn."})}),"\n",(0,i.jsx)(t.p,{children:"Until the player takes the first turn the match will not be in a state that will\ntrigger notifications to other players and they won't receive invitations to the game or match."}),"\n",(0,i.jsx)(t.h2,{id:"loading-matches",children:"Loading Matches"}),"\n",(0,i.jsxs)(t.p,{children:["To load matches currently in progress for the current player you can call the ",(0,i.jsx)(t.code,{children:"loadMatches"}),"\nfunction."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"GameServices.service.turnBasedMultiplayer.loadMatches();\n"})}),"\n",(0,i.jsx)(t.p,{children:"You can also specify loading matches that are in a particular turn status for the player\nby passing an array of statuses to the loadMatches call. For example, to load all matches\nthat it is currently the players turn:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"GameServices.service.turnBasedMultiplayer.loadMatches( [ TurnBasedMatchStatus.MATCH_TURN_STATUS_MY_TURN ] );\n"})}),"\n",(0,i.jsx)(t.p,{children:"The call will dispatch an event when complete, being either:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMultiplayerEvent.LOADMATCHES_SUCCESS"}),": When successful. The event will contain the loaded matches"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMultiplayerEvent.LOADMATCHES_FAILED"}),": If an error occurred."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"GameServices.service.turnBasedMultiplayer.addEventListener( TurnBasedMultiplayerEvent.LOADMATCHES_SUCCESS, loadMatchesSuccessHandler );\nGameServices.service.turnBasedMultiplayer.addEventListener( TurnBasedMultiplayerEvent.LOADMATCHES_FAILED, loadMatchesFailedHandler );\n"})}),"\n",(0,i.jsx)(t.p,{children:"On success the matches are available through the event payload. You can immediately start\nusing these match objects, listening for updates or taking turns as required."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:'function loadMatchesSuccessHandler( event:TurnBasedMultiplayerEvent ):void \n{\n\tfor each (var match:TurnBasedMatch in event.data)\n\t{\n\t\tmessage( "MATCH :: ["+match.matchId+"] "+match.status );\n\t\t\n\t\t// Display matches to user or process as required by your application\n\t}\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"match-data",children:"Match Data"}),"\n",(0,i.jsxs)(t.p,{children:["The match data is a ",(0,i.jsx)(t.code,{children:"ByteArray"})," object that you can use as requried to store data,\nhowever it is size limited so you should take efforts to minimise the size of the\ndata required by your game."]}),"\n",(0,i.jsx)(t.p,{children:"Some general strategies of encoding the data include:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Encode only player actions"}),": In this design, your match data simply consists of the moves made by the players. For example, in chess, you know that white goes first, moves always alternate, and a piece moves from one board position to another. This makes it easy for you to encode each move as the starting and ending position of the piece moved. The rest of the data (who made the moves) can be completely inferred. When your game loads the match data, it quickly replays the moves to generate the current board position.\nThis strategy works best for games with a small number of possible kinds of actions and a small number of moves per match. Also, with this model, it is very possible for your game to replay the moves in its user interface, allowing players to see exactly what moves other opponents made to get the board into the new state. Showing a player these moves makes it very easy for a player to understand how the game got to the current state."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Encode only the current state of the match"}),": For very complex games, the actual state required to encode the game could be very large. In this case, you may need to encode the current state of the match without worrying about the actions that generated that match data. This is particularly true for very complex games where the list of moves might grow too large to fit in the available storage space. This strategy is recommended as a last resort. Players lose all context of what happened on previous turns of the match. For games with long timeouts between turns, players may grow bored or frustrated if they cannot remember the state of a match they were playing. This is particularly true when players participate in multiple matches simultaneously."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Encode the current state of the match and a set of recent player actions"}),": This is a hybrid strategy that borrows elements from the other two strategies. Essentially, the match data stored on Game Center consists of a recent snapshot of the match plus other data that encodes recent actions since that last snapshot was taken. When the data that records the actions grows too large, your game replays some of those moves to update the match snapshot and then deletes those moves from its list of actions."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The size of the match data is limited to:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"64kb on Game Center"}),"\n",(0,i.jsx)(t.li,{children:"128kb on Google Play Games"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"taking-turns",children:"Taking Turns"}),"\n",(0,i.jsxs)(t.p,{children:["To take a turn you will be updating the data in the ",(0,i.jsx)(t.code,{children:"match"})," object and then calling\n",(0,i.jsx)(t.code,{children:"takeTurn"})," specifying the next participant."]}),"\n",(0,i.jsxs)(t.p,{children:["The next participant can be any of the participants in the match which are available\nthrough the ",(0,i.jsx)(t.code,{children:"match.participants"})," array of ",(0,i.jsx)(t.code,{children:"Participant"})," objects or you can specify\nnull if you wish for an auto matched player to take the next turn."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"// Update the match data\nmatch.data.writeInt(  ... );\n\n// Determine your next player based on your game rules\nvar next:Participant = ...;\n\n// Call takeTurn to end the turn and move play to next participant\nmatch.takeTurn( next );\n"})}),"\n",(0,i.jsx)(t.p,{children:"The local player will also be indexed in the match participants so it is sometimes\nuseful to find the index of the local player in the participants."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"var localPlayer:Player = GameServices.service.getPlayer();\n\nfor (var j:int = 0; j < match.participants.length; ++j)\n{\n\tif (Participant(match.participants[j]).player.id == localPlayer.id)\n\t{\n\t\tlocalPlayerIndex = j;\n\t}\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"So for example your game might just iterate through the participants in turn\norder:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"//\tTake the next player in the participants \nvar nextIndex:int = (localPlayerIndex + 1 >= match.participants.length) ? 0 : localPlayerIndex + 1 ;\n\n// If this is an auto-match game, then there may only be one player, in which case\n// \tyou will want to pass a mull value for the next participant allowing an auto match\n//\tplayer to take their turn.\n\nvar next:Participant = null;\nif (nextIndex != localPlayerIndex)\n\tnext = _match.participants[ nextIndex ];\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The call to ",(0,i.jsx)(t.code,{children:"takeTurn"})," will dispatch an event on completion:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMatchEvent.TAKETURN_SUCCESS"}),": If the call is successful"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMatchEvent.TAKETURN_FAILED"}),": If there was an error taking the turn, you should try the call again later."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"match-updates",children:"Match Updates"}),"\n",(0,i.jsxs)(t.p,{children:["When another participant changes the state of the match your application will\nreceive the ",(0,i.jsx)(t.code,{children:"MATCH_UPDATED"})," event."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"GameServices.service.turnBasedMultiplayer.addEventListener( TurnBasedMatchEvent.MATCH_UPDATED, matchUpdatedHandler );\n"})}),"\n",(0,i.jsxs)(t.p,{children:["When you receive this event you should update your application with the match in the event\nThe updated ",(0,i.jsx)(t.code,{children:"match"})," will contain the latest match status and data."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"function matchUpdatedHandler( event:TurnBasedMatchEvent ):void \n{\n\tupdateMatch( event.match );\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"function updateMatch( match:TurnBasedMatch ):void\n{\n\t// Clear out the old match reference if you are holding onto one\n\tif (_match)\n\t{\n\t\t_match.removeEventListener( TurnBasedMatchEvent.TAKETURN_SUCCESS, match_takeTurnSuccessHandler );\n\t\t// ... \n\t}\n\n\t// Update with the new reference\n\t_match = match;\n\tif (_match)\n\t{\n\t\t_match.addEventListener( TurnBasedMatchEvent.TAKETURN_SUCCESS, match_takeTurnSuccessHandler );\n\t\t// ...\n\n\t\t// You should now process the match state checking if the status has changed \n\t\t// and the turn status to see which player is now active\n\t\tprocessMatchState();\n\t}\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If you have multiple matches you should also use the ",(0,i.jsx)(t.code,{children:"matchId"})," to distinguish between\nthe different matches in progress."]}),"\n",(0,i.jsx)(t.h2,{id:"leaving-a-match",children:"Leaving a Match"}),"\n",(0,i.jsxs)(t.p,{children:["If a player wishes to leave a match you should call ",(0,i.jsx)(t.code,{children:"leaveMatchDuringTurn"})," if it is the\nplayers turn or ",(0,i.jsx)(t.code,{children:"leaveMatch"})," if not. If it is the players turn it is important that\nyou call ",(0,i.jsx)(t.code,{children:"leaveMatchDuringTurn"})," and specify the player that will take the next turn\nbased on your game logic, so that the match may continue for the other players."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"if (match.turnStatus == TurnBasedMatchStatus.MATCH_TURN_STATUS_MY_TURN)\n{\n\t// Determine the next participant based on your game logic\n\tvar next:Participant = ...;\n\t\n\tmatch.leaveMatchDuringTurn( next );\n}\nelse\n{\n\tmatch.leaveMatch();\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Calling these functions will result in one of the following events:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMatchEvent.LEAVE_SUCCESS"}),": Dispatched if the leave call was successful and the player is no longer an active participant."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMatchEvent.LEAVE_FAILED"}),": Dispatched if the leave call failed. Check the error for details."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"completing-a-match",children:"Completing a Match"}),"\n",(0,i.jsxs)(t.p,{children:["Completing or finishing a match involves calling ",(0,i.jsx)(t.code,{children:"finishMatch"})," and specifying the result.\nThis should be called by the player taking the last turn in the match and call this method\ninstead of ",(0,i.jsx)(t.code,{children:"takeTurn"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The result of the match is specified by an Array of ",(0,i.jsx)(t.code,{children:"ParticipantResult"})," objects for each\nof the participants in the match that require a result. If there is simply a winner, then\nyou can use a single ",(0,i.jsx)(t.code,{children:"ParticipantResult"})," in this Array."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"var winner:ParticipantResult = new ParticipantResult();\nwinner.result       = ParticipantResult.MATCH_RESULT_WIN;\nwinner.participant  = ...; // Participant from match.participants array that has won\nwinner.placing      = 1;\n\nmatch.finishMatch( [ winner ] );\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The call to ",(0,i.jsx)(t.code,{children:"finishMatch"})," will dispatch one of the following events:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMatchEvent.FINISH_SUCCESS"}),": Dispatched when ",(0,i.jsx)(t.code,{children:"finishMatch"})," is successful"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TurnBasedMatchEvent.FINISH_FAILED"}),": Dispatched when ",(0,i.jsx)(t.code,{children:"finishMatch"})," has failed, you should attempt the call again later"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-actionscript",children:"match.addEventListener( TurnBasedMatchEvent.FINISH_SUCCESS, finishSuccessHandler );\n\nfunction finishSuccessHandler( event:TurnBasedMatchEvent ):void \n{\n\t// Match will now be complete\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}}}]);