"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[54804],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var a=n(96540);const s={},i=a.createContext(s);function r(e){const t=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}},82733:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"firebase/database/transactions","title":"Database - Transactions","description":"Transactions","source":"@site/docs/firebase/database/transactions.md","sourceDirName":"firebase/database","slug":"/firebase/database/transactions","permalink":"/docs/firebase/database/transactions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Database - Transactions","sidebar_label":"Transactions"},"sidebar":"firebase","previous":{"title":"Delete Data","permalink":"/docs/firebase/database/delete-data"},"next":{"title":"Lists","permalink":"/docs/firebase/database/lists"}}');var s=n(74848),i=n(28453);const r={title:"Database - Transactions",sidebar_label:"Transactions"},c=void 0,o={},l=[{value:"Transactions",id:"transactions",level:2}];function u(e){const t={blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"transactions",children:"Transactions"}),"\n",(0,s.jsx)(t.p,{children:"When working with data that could be corrupted by concurrent modifications, such\nas incremental counters, you can use a transaction operation."}),"\n",(0,s.jsxs)(t.p,{children:["You give this operation an important argument: an instance of a ",(0,s.jsx)(t.code,{children:"TransactionHandler"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"This class will implement a function that takes the current state of the data as an\nargument and returns the new desired state you would like to write. If another client\nwrites to the location before your new value is successfully written, your update\nfunction is called again with the new current value, and the write is retried."}),"\n",(0,s.jsx)(t.p,{children:"Using a transaction prevents data from being incorrect if multiple users change the\nsame data at the same time or the client had stale data. If the transaction is rejected,\nthe server returns the current value to the client, which runs the transaction again\nwith the updated value. This repeats until the transaction is accepted or too many\nattempts have been made."}),"\n",(0,s.jsxs)(t.p,{children:["In the following example we will start a transaction, by calling ",(0,s.jsx)(t.code,{children:"runTransaction()"}),"\non a ",(0,s.jsx)(t.code,{children:"DatabaseReference"})," and pass in an instance of a class that implements the\n",(0,s.jsx)(t.code,{children:"TransactionHandler"})," interface."]}),"\n",(0,s.jsx)(t.p,{children:'We will attempt to increment a "count" value which will be a synchronised counter.'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-actionscript",children:'var ref:DatabaseReference = FirebaseDatabase.service.getReference( "count" );\n\nref.runTransaction( new CountTransactionHandler() );\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The implementation of the ",(0,s.jsx)(t.code,{children:"CountTransactionHandler"})," sets the logic for updating\nthe value of the data. It has one function ",(0,s.jsx)(t.code,{children:"doTransaction"})," that will be called\neach time the Firebase transaction requires updating of the data value.\nHere we will increment the count value:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-actionscript",children:"public class CountTransactionHandler implements TransactionHandler\n{\n\t\n\tpublic function doTransaction( mutableData:MutableData ):TransactionResult\n\t{\n\t\tvar data:Object = mutableData.getValue();\n\t\tif (data == null)\n\t\t{\n\t\t\t// Set an initial value\n\t\t\tmutableData.setValue( 0 );\n\t\t\treturn TransactionResult.success(mutableData);\n\t\t}\n\t\tmutableData.setValue( mutableData.getValue() + 1 );\n\t\treturn TransactionResult.success(mutableData);\n\t}\n\t\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["You can use any logic in this ",(0,s.jsx)(t.code,{children:"doTransaction"})," function that you require. However it\nis important that you return a ",(0,s.jsx)(t.code,{children:"TransactionResult"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["on ",(0,s.jsx)(t.strong,{children:"success"})," use: ",(0,s.jsx)(t.code,{children:"TransactionResult.success( mutableData );"})]}),"\n",(0,s.jsxs)(t.li,{children:["on ",(0,s.jsx)(t.strong,{children:"failure"})," use: ",(0,s.jsx)(t.code,{children:"TransactionResult.abort();"})]}),"\n"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["Note: Because ",(0,s.jsx)(t.code,{children:"doTransaction()"})," is called multiple times, it must be able to handle\n",(0,s.jsx)(t.code,{children:"null"})," data. Even if there is existing data in your remote database, it may not be\nlocally cached when the transaction function is run, resulting in ",(0,s.jsx)(t.code,{children:"null"})," for the\ninitial value."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);