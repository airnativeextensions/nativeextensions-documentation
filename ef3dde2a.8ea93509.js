(window.webpackJsonp=window.webpackJsonp||[]).push([[773],{831:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return s})),a.d(t,"metadata",(function(){return o})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return p}));var n=a(2),r=a(6),i=(a(0),a(892)),s={title:"Database - Offline",sidebar_label:"Offline"},o={unversionedId:"firebase/database/offline",id:"firebase/database/offline",isDocsHomePage:!1,title:"Database - Offline",description:"Write data offline",source:"@site/docs/firebase/database/offline.md",slug:"/firebase/database/offline",permalink:"/docs/firebase/database/offline",version:"current",sidebar_label:"Offline",sidebar:"firebase",previous:{title:"Database - Lists",permalink:"/docs/firebase/database/lists"},next:{title:"Database - Disconnect",permalink:"/docs/firebase/database/disconnect"}},l=[{value:"Write data offline",id:"write-data-offline",children:[]},{value:"Enabling Offline Capabilities",id:"enabling-offline-capabilities",children:[{value:"Keeping Data Fresh",id:"keeping-data-fresh",children:[]}]}],c={rightToc:l};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"write-data-offline"},"Write data offline"),Object(i.b)("p",null,"If a client loses its network connection, your app will continue functioning correctly."),Object(i.b)("p",null,'Every client connected to a Firebase database maintains its own internal version of any\nactive data. When data is written, it\'s written to this local version first. The Firebase\nclient then synchronizes that data with the remote database servers and with other clients\non a "best-effort" basis.'),Object(i.b)("p",null,"As a result, all writes to the database trigger local events immediately, before any data\nis written to the server. This means your app remains responsive regardless of network\nlatency or connectivity."),Object(i.b)("p",null,"Once connectivity is reestablished, your app receives the appropriate set of events so\nthat the client syncs with the current server state, without having to write any custom code."),Object(i.b)("h2",{id:"enabling-offline-capabilities"},"Enabling Offline Capabilities"),Object(i.b)("p",null,"In addition, Firebase provides tools for persisting data locally, managing presence,\nand handling latency."),Object(i.b)("p",null,"Firebase apps automatically handle temporary network interruptions. Cached data is\navailable while offline and Firebase resends any writes when network connectivity is\nrestored."),Object(i.b)("p",null,"When you enable disk persistence, your app writes the data locally to the device so\nyour app can maintain state while offline, even if the user or operating system restarts\nthe app."),Object(i.b)("p",null,"You can enable disk persistence with just one line of code."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-actionscript"}),"FirebaseDatabase.service.setPersistenceEnabled( true );\n")),Object(i.b)("p",null,"By enabling persistence, any data that the Firebase Realtime Database client would\nsync while online persists to disk and is available offline, even when the user or\noperating system restarts the app. This means your app works as it would online by\nusing the local data stored in the cache. Listener callbacks will continue to fire\nfor local updates."),Object(i.b)("p",null,"The Firebase Realtime Database client automatically keeps a queue of all write\noperations that are performed while your app is offline. When persistence is\nenabled, this queue is also persisted to disk so all of your writes are available\nwhen the user or operating system restarts the app. When the app regains connectivity,\nall of the operations are sent to the Firebase Realtime Database server."),Object(i.b)("p",null,"If your app uses Firebase Authentication, the Firebase Realtime Database client\npersists the user's authentication token across app restarts. If the auth token\nexpires while your app is offline, the client pauses write operations until your\napp re-authenticates the user, otherwise the write operations might fail due to\nsecurity rules."),Object(i.b)("h3",{id:"keeping-data-fresh"},"Keeping Data Fresh"),Object(i.b)("p",null,"The Firebase Realtime Database synchronizes and stores a local copy of the data\nfor active listeners. In addition, you can keep specific locations in sync."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-actionscript"}),'var ref:DatabaseReference = FirebaseDatabase.service.getReference("scores");\nref.keepSynced(true);\n')),Object(i.b)("p",null,"The Firebase Realtime Database client automatically downloads the data at these\nlocations and keeps it in sync even if the reference has no active listeners.\nYou can turn synchronization back off with the following line of code."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-actionscript"}),"ref.keepSynced(false);\n")),Object(i.b)("p",null,"By default, 10MB of previously synced data is cached. This should be enough for\nmost applications. If the cache outgrows its configured size, the Firebase Realtime\nDatabase purges data that has been used least recently. Data that is kept in sync\nis not purged from the cache."))}p.isMDXComponent=!0},892:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return d}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},b=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},f=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=p(a),f=n,d=b["".concat(s,".").concat(f)]||b[f]||u[f]||i;return a?r.a.createElement(d,o(o({ref:t},c),{},{components:a})):r.a.createElement(d,o({ref:t},c))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,s=new Array(i);s[0]=f;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:n,s[1]=o;for(var c=2;c<i;c++)s[c]=a[c];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,a)}f.displayName="MDXCreateElement"}}]);