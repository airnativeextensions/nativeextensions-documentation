"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[85473],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,f=d["".concat(s,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),r=n(86010);const o={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,i),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>N});var a=n(87462),r=n(67294),o=n(86010),i=n(12466),l=n(16550),s=n(91980),c=n(67392),u=n(50012);function d(e){return function(e){var t,n;return null!=(t=null==(n=r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:n.filter(Boolean))?t:[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function p(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=null!=t?t:d(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:n}=e;const a=(0,l.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=n?n:null}({queryString:t,groupId:n});return[(0,s._X)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function h(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,o=p(e),[i,l]=(0,r.useState)((()=>function(e){var t;let{defaultValue:n,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}const r=null!=(t=a.find((e=>e.default)))?t:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[s,c]=f({queryString:n,groupId:a}),[d,h]=function(e){let{groupId:t}=e;const n=function(e){return e?"docusaurus.tab."+e:null}(t),[a,o]=(0,u.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:a}),g=(()=>{const e=null!=s?s:d;return m({value:e,tabValues:o})?e:null})();(0,r.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error("Can't select invalid tab value="+e);l(e),c(e),h(e)}),[c,h,o]),tabValues:o}}var g=n(72389);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:n,selectedValue:l,selectValue:s,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.o5)(),p=e=>{const t=e.currentTarget,n=u.indexOf(t),a=c[n].value;a!==l&&(d(t),s(a))},m=e=>{var t;let n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{var a;const t=u.indexOf(e.currentTarget)+1;n=null!=(a=u[t])?a:u[0];break}case"ArrowLeft":{var r;const t=u.indexOf(e.currentTarget)-1;n=null!=(r=u[t])?r:u[u.length-1];break}}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>u.push(e),onKeyDown:m,onClick:p},i,{className:(0,o.Z)("tabs__item",v.tabItem,null==i?void 0:i.className,{"tabs__item--active":l===t})}),null!=n?n:t)})))}function b(e){let{lazy:t,children:n,selectedValue:a}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function k(e){const t=h(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",v.tabList)},r.createElement(y,(0,a.Z)({},e,t)),r.createElement(b,(0,a.Z)({},e,t)))}function N(e){const t=(0,g.Z)();return r.createElement(k,(0,a.Z)({key:String(t)},e))}},89750:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>f,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var a=n(87462),r=(n(67294),n(3905)),o=n(74866),i=n(85162);const l={title:"Scanning",sidebar_label:"Overview"},s=void 0,c={unversionedId:"nfc/scanning",id:"nfc/scanning",title:"Scanning",description:"Tags",source:"@site/docs/nfc/scanning.mdx",sourceDirName:"nfc",slug:"/nfc/scanning",permalink:"/docs/nfc/scanning",draft:!1,tags:[],version:"current",frontMatter:{title:"Scanning",sidebar_label:"Overview"},sidebar:"nfc",previous:{title:"Unity",permalink:"/docs/nfc/add-the-plugin"},next:{title:"Dispatch Mode",permalink:"/docs/nfc/dispatch-mode"}},u={},d=[{value:"Tags",id:"tags",level:2},{value:"Events",id:"events",level:2},{value:"<code>NdefRecord</code> Payload",id:"ndefrecord-payload",level:3},{value:"Modes",id:"modes",level:2}],p={toc:d},m="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"tags"},"Tags"),(0,r.kt)("p",null,"NFC tags come in a wide array of technologies and can also have data written to them in many different ways. Android and iOS has the most support for the NDEF standard, which is defined by the ",(0,r.kt)("a",{parentName:"p",href:"https://nfc-forum.org/home"},"NFC Forum"),"."),(0,r.kt)("p",null,"NDEF data is encapsulated inside a message (",(0,r.kt)("inlineCode",{parentName:"p"},"NdefMessage"),") that contains one or more records (",(0,r.kt)("inlineCode",{parentName:"p"},"NdefRecord"),"). Each NDEF record must be well-formed according to the specification of the type of record that you want to create."),(0,r.kt)("h2",{id:"events"},"Events"),(0,r.kt)("p",null,"Your application will get notified about NFC tag detection events via the ",(0,r.kt)("inlineCode",{parentName:"p"},"NFCEvent"),". This is independent of the mode. The most relevant event is the ",(0,r.kt)("inlineCode",{parentName:"p"},"NFCEvent.ACTION_NDEF_DISCOVERED")," which is dispatched whenever an applicable NDEF NFC tag is detected."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"NFCEvent")," will contain a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tag")," object in the ",(0,r.kt)("inlineCode",{parentName:"p"},"tag")," variable. This contains all the information available about the detected tag, including ",(0,r.kt)("inlineCode",{parentName:"p"},"NdefMessage"),"s and ",(0,r.kt)("inlineCode",{parentName:"p"},"NdefRecord"),"s contained in the tag. "),(0,r.kt)(o.Z,{groupId:"framework",defaultValue:"air",values:[{label:"AIR",value:"air"},{label:"Unity",value:"unity"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"air",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-actionscript"},'NFC.service.addEventListener( NFCEvent.ACTION_NDEF_DISCOVERED, discoveredHandler );\n\nfunction discoveredHandler( event:NFCEvent ):void\n{\n    trace( "discoveredHandler" );\n    for each (var message:NdefMessage in event.tag.messages)\n    {\n        for each (var record:NdefRecord in message.records)\n        {\n            trace( "\\t"+record.toString() + "::"+record.payload.toString() +" url:"+record.url );\n        }\n    }\n}\n'))),(0,r.kt)(i.Z,{value:"unity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'NFC.Instance.OnNdefDiscovered += Instance_OnNdefDiscovered;\n\nvoid Instance_OnNdefDiscovered(NFCEvent e)\n{\n    Debug.Log("Instance_OnNdefDiscovered");\n    foreach (NdefMessage message in e.tag.messages)\n    {\n        foreach (NdefRecord record in message.records)\n        {\n            Log("  record.payload: " + record.payload);\n        }\n    }\n}\n')))),(0,r.kt)("h3",{id:"ndefrecord-payload"},(0,r.kt)("inlineCode",{parentName:"h3"},"NdefRecord")," Payload"),(0,r.kt)("p",null,"The payload of the records contains data in a specific format. "),(0,r.kt)(o.Z,{groupId:"framework",defaultValue:"air",values:[{label:"AIR",value:"air"},{label:"Unity",value:"unity"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"air",mdxType:"TabItem"},(0,r.kt)("p",null,"The payload in an ",(0,r.kt)("inlineCode",{parentName:"p"},"NdefRecord")," is encoded as a ",(0,r.kt)("inlineCode",{parentName:"p"},"ByteArray"),". "),(0,r.kt)("p",null,"If you are expecting ascii string data you can just read the data using ",(0,r.kt)("inlineCode",{parentName:"p"},"toString()"),", eg:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-actionscript"},"var record:NdefRecord = ...;\nvar payloadAsString:String = record.payload.toString();\n"))),(0,r.kt)(i.Z,{value:"unity",mdxType:"TabItem"},(0,r.kt)("p",null,"The payload in an ",(0,r.kt)("inlineCode",{parentName:"p"},"NdefRecord")," is encoded as a hexidecimal ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". "),(0,r.kt)("p",null,"Records are actually byte data the payload which we read as hex string array to ensure it is passed from the native layer in the same format across platforms. "),(0,r.kt)("p",null,"To convert it to a byte array:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public static byte[] StringToByteArray(string hexString)\n{\u200b\n  byte[] bytes = new byte[\u200bhexString.Length / 2];\n  for (int i = 0; i < \u200bhexString.Length; i += 2) \n  {\n    bytes[i / 2] = System.Convert.ToByte(hexString.Substring(i, 2), 16);\n  }\n  return bytes;\n}\n")),(0,r.kt)("p",null,"If you are expecting ascii string data you can take this further:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public static string StringToASCII(string hexString)\n{\n    try\n    {\n        string ascii = string.Empty;\n        for (int i = 0; i < hexString.Length; i += 2)\n        {\n            byte val = System.Convert.ToByte(hexString.Substring(i, 2), 16);\n            char character = System.Convert.ToChar(\u200bval);\n            ascii += character;\n        }\n        return ascii;\n    }\n    catch (Exception ex) { Console.WriteLine(ex.Message); }\n    return string.Empty;\n}\n")))),(0,r.kt)("h2",{id:"modes"},"Modes"),(0,r.kt)("p",null,"There are two modes of scanning for tags, which we reference as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/nfc/dispatch-mode"},'"dispatch mode"'),", where you are listening for system dispatched events;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/nfc/reader-mode"},'"reader mode"'),", where you are actively reading tags; ")),(0,r.kt)("p",null,"Both are very similar, and will communicate via the same events as above. The main differences being that:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"reader mode active reads tags and can read a tag multiple times if required, however;"),(0,r.kt)("li",{parentName:"ol"},"reader mode mode interferes with other NFC functionality disabling any peer-to-peer (Android Beam) and card-emulation modes of the NFC adapter on this device;"),(0,r.kt)("li",{parentName:"ol"},"reader mode is only available while your application is active, i.e ",(0,r.kt)("strong",{parentName:"li"},"only dispatch mode supports background scanning")," and launching your application from a tag.")),(0,r.kt)("p",null,"As a general rule, you should use dispatch mode, unless you really need to read a tag multiple times. "),(0,r.kt)("p",null,"There is also no reason that you can't combine the two, using dispatch mode to register your application for launches from tags and using reader mode to actively scan while your application is in use."))}f.isMDXComponent=!0}}]);