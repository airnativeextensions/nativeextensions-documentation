"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[67066],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return d}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=r.createContext({}),p=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(o.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=p(t),d=a,g=h["".concat(o,".").concat(d)]||h[d]||c[d]||i;return t?r.createElement(g,s(s({ref:n},u),{},{components:t})):r.createElement(g,s({ref:n},u))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=h;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var p=2;p<i;p++)s[p]=t[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},41022:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return o},default:function(){return d},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return c}});var r=t(83117),a=t(80102),i=(t(67294),t(3905)),s=["components"],l={title:"Pending Purchases",sidebar_label:"Pending Purchases"},o=void 0,p={unversionedId:"inappbilling/pending-purchases",id:"inappbilling/pending-purchases",title:"Pending Purchases",description:"Interupted / Pending / Acknowledging Purchases",source:"@site/docs/inappbilling/pending-purchases.md",sourceDirName:"inappbilling",slug:"/inappbilling/pending-purchases",permalink:"/docs/inappbilling/pending-purchases",draft:!1,tags:[],version:"current",frontMatter:{title:"Pending Purchases",sidebar_label:"Pending Purchases"},sidebar:"inappbilling",previous:{title:"Make a Purchase",permalink:"/docs/inappbilling/make-a-purchase"},next:{title:"Restore Purchases",permalink:"/docs/inappbilling/restore-purchases"}},u={},c=[{value:"Get Pending Purchases",id:"get-pending-purchases",level:2},{value:"Setup",id:"setup",level:2},{value:"Google Play Billing Acknowledgement",id:"google-play-billing-acknowledgement",level:2}],h={toc:c};function d(e){var n=e.components,t=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Interupted / Pending / Acknowledging Purchases")),(0,i.kt)("p",null,"Pending purchases are purchases that are currently still in progress and you are yet to deliver the appropriate product and call ",(0,i.kt)("inlineCode",{parentName:"p"},"finishPurchase()"),"."),(0,i.kt)("p",null,"Pending purchases may occur when a purchase is interupted, for example, the user left the application during a purchase, or they were initiated from an external source."),(0,i.kt)("p",null,"Purchases will remain in the pending purchases queue until you call ",(0,i.kt)("inlineCode",{parentName:"p"},"finishPurchase()")," with the appropriate purchase. "),(0,i.kt)("p",null,"The main reason for this process is to allow you to verify the transaction with your server before delivering the product to your user and informing the billing service that the purchase has been delivered to the user."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"From version 8, this process is applicable to Apple's In-App Purchases, Google Play Billing and Amazon In-App Purchases!"),"\nThe process continues to work across all services and platforms.")),(0,i.kt)("p",null,"The services use slightly different terminology in their documentation you may need to be aware of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Apple uses "pending";'),(0,i.kt)("li",{parentName:"ul"},'Google uses "acknowledged", i.e. an un-acknowledged purchase is a pending purchase, ',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'when we finish a purchase we "acknowledge" the purchase;'))),(0,i.kt)("li",{parentName:"ul"},'Amazon uses "fulfilled", i.e. an un-fulfillled purchase is a pending purchase, ',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'when we finish a purchase we "notify of fulfillment" of the purchase;')))),(0,i.kt)("h2",{id:"get-pending-purchases"},"Get Pending Purchases"),(0,i.kt)("p",null,"You can retrieve the list of pending purchases by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"getPendingPurchases()")," function. This will return the array of ",(0,i.kt)("inlineCode",{parentName:"p"},"Purchase")," objects that are currently 'pending'."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},"// Check for any pending purchases\nvar pendingPurchases:Array = InAppBilling.service.getPendingPurchases();\nfor each (var p:Purchase in pendingPurchases)\n{\n    // You should process any pending purchases here and then finish if necessary\n    processPurchase( p );\n}\n")),(0,i.kt)("h2",{id:"setup"},"Setup"),(0,i.kt)("p",null,"The pending purchases queue may not be initialised immediately, so you may find that in your ",(0,i.kt)("inlineCode",{parentName:"p"},"InAppBillingEvent.SETUP_SUCCESS")," event handler that the pending purchases queue is empty even though there are pending purchases."),(0,i.kt)("p",null,"The queue can be updated just after setup has completed which will be indicated by the normal ",(0,i.kt)("inlineCode",{parentName:"p"},"PurchaseEvent.PURCHASES_UPDATED")," event. This is particularly true on iOS/tvOS where the payment queue update (which populates the pending purchases) will occur a short time after setup succeeds."),(0,i.kt)("p",null,"We suggest you add event listeners for the ",(0,i.kt)("inlineCode",{parentName:"p"},"PurchaseEvent.PURCHASES_UPDATED")," event before you call ",(0,i.kt)("inlineCode",{parentName:"p"},"setup()")," to make sure you process all pending notifications at startup. You should also perform a check of the pending purchcases in your ",(0,i.kt)("inlineCode",{parentName:"p"},"InAppBillingEvent.SETUP_SUCCESS")," handler. Purchases that are already available at startup may not trigger a purchases updated event so you must handling purchases in both cases."),(0,i.kt)("p",null,"For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-actionscript"},"// Add purchases updated handler\nInAppBilling.service.addEventListener( PurchaseEvent.PURCHASES_UPDATED, purchases_updatedHandler );\n\nInAppBilling.service.addEventListener( InAppBillingEvent.SETUP_SUCCESS, setup_successHandler );\nInAppBilling.service.addEventListener( InAppBillingEvent.SETUP_FAILURE, setup_failureHandler );\n\nInAppBilling.service.setup(\n        new BillingService()\n                .setGooglePlayPublicKey( GOOGLE_PLAY_INAPP_BILLING_KEY )\n);\n\nfunction setup_successHandler( event:InAppBillingEvent ):void \n{\n    // Check for pending purchases that are already available\n    for each (var p:Purchase in InAppBilling.service.getPendingPurchases())\n    {\n        processPurchase( p );\n    }\n}\n\nfunction purchases_updatedHandler( event:PurchaseEvent ):void \n{\n    // Your standard purchase queue handler\n\n    for each (var purchase:Purchase in event.data)\n    {\n        processPurchase( p );\n    }\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: Do not rely on the ",(0,i.kt)("inlineCode",{parentName:"p"},"PurchaseEvent.PURCHASES_UPDATED")," event as part of your flow. This event may not be dispatched if there aren't any pending purchases, or if they are available in the setup success handler.")),(0,i.kt)("h2",{id:"google-play-billing-acknowledgement"},"Google Play Billing Acknowledgement"),(0,i.kt)("p",null,"With Google Play Billing the call to ",(0,i.kt)("inlineCode",{parentName:"p"},"finishPurchase()")," performs the acknowledgement of the purchase."),(0,i.kt)("p",null,"It's very important to note that if you don't acknowledge a purchase (i.e. call finish purchase) it will be refunded."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Google Play supports purchasing products from inside of your app (in-app) or outside of your app (out-of-app). In order for Google Play to ensure a consistent purchase experience regardless of where the user purchases your product, you must acknowledge all purchases received through the Google Play Billing Library as soon as possible after granting entitlement to the user. If you do not acknowledge a purchase within three days, the user automatically receives a refund, and Google Play revokes the purchase. ")))}d.isMDXComponent=!0}}]);