"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[20683],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return p}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),p=r,m=d["".concat(l,".").concat(p)]||d[p]||h[p]||o;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},25273:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return h}});var a=n(87462),r=n(63366),o=(n(67294),n(3905)),s=["components"],i={title:"Firestore - Get realtime updates",sidebar_label:"Get realtime updates"},l=void 0,c={unversionedId:"firebase/firestore/get-realtime-updates",id:"firebase/firestore/get-realtime-updates",title:"Firestore - Get realtime updates",description:"You can listen to document updates by adding a listener for the DocumentReference.SNAPSHOT_EVENT or by calling the addSnapshotListener() method.",source:"@site/docs/firebase/firestore/get-realtime-updates.md",sourceDirName:"firebase/firestore",slug:"/firebase/firestore/get-realtime-updates",permalink:"/docs/firebase/firestore/get-realtime-updates",draft:!1,tags:[],version:"current",frontMatter:{title:"Firestore - Get realtime updates",sidebar_label:"Get realtime updates"},sidebar:"firebase",previous:{title:"Get data",permalink:"/docs/firebase/firestore/get-data"},next:{title:"Perform simple and compound queries",permalink:"/docs/firebase/firestore/perform-simple-and-compound-queries"}},u={},h=[{value:"Events for local changes",id:"events-for-local-changes",level:2},{value:"Events for metadata changes",id:"events-for-metadata-changes",level:2},{value:"Listen to multiple documents in a collection",id:"listen-to-multiple-documents-in-a-collection",level:2},{value:"View changes between snapshots",id:"view-changes-between-snapshots",level:2},{value:"Detach a listener",id:"detach-a-listener",level:2}],d={toc:h};function p(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"You can listen to document updates by adding a listener for the ",(0,o.kt)("inlineCode",{parentName:"p"},"DocumentReference.SNAPSHOT_EVENT")," or by calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"addSnapshotListener()")," method. "),(0,o.kt)("p",null,"Adding this listener to the document will create a snapshot event immediately with the current contents of the single document. Then, each time the contents change, another event will be dispatched with the updates to the document snapshot."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'var document:DocumentReference = FirebaseFirestore.service.collection("cities").document("SF");\ndocument.addSnapshotListener( snapshotEventHandler );\n\nfunction snapshotEventHandler( event:DocumentReferenceEvent ):void \n{\n    var snapshot:DocumentSnapshot = event.snapshot;\n    if (event.message != "") \n    {\n        trace( "Error fetching document: " + event.message );\n    }\n    else \n    {\n        if (snapshot != null && snapshot.exists())\n        {\n            trace( JSON.stringify( snapshot.getData() ) );\n        }\n    }\n}\n')),(0,o.kt)("h2",{id:"events-for-local-changes"},"Events for local changes"),(0,o.kt)("p",null,'Local writes in your app will invoke snapshot listeners immediately. This is because of an important feature called "latency compensation." When you perform a write, your listeners will be notified with the new data before the data is sent to the backend.'),(0,o.kt)("p",null,"Retrieved documents have a ",(0,o.kt)("inlineCode",{parentName:"p"},"metadata.hasPendingWrites")," property that indicates whether the document has local changes that haven't been written to the backend yet. You can use this property to determine the source of events received by your snapshot listener:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'function snapshotEventHandler( event:DocumentReferenceEvent ):void \n{\n    var snapshot:DocumentSnapshot = event.snapshot;\n    if (event.message != null && event.message != "") \n    {\n        trace( "Error fetching document: " + event.message );\n    }\n    else \n    {\n        var source:String = snapshot.getMetadata().hasPendingWrites ? "Local" : "Server";\n        // ...\n    }\n}\n')),(0,o.kt)("h2",{id:"events-for-metadata-changes"},"Events for metadata changes"),(0,o.kt)("p",null,"When listening for changes to a document, collection, or query, you can pass options to control the granularity of events that your listener will receive."),(0,o.kt)("p",null,"By default, listeners are not notified of changes that only affect metadata. Consider what happens when your app writes a new document:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'A change event is immediately fired with the new data. The document has not yet been written to the backend so so the "pending writes" flag is true.'),(0,o.kt)("li",{parentName:"ul"},"The document is written to the backend."),(0,o.kt)("li",{parentName:"ul"},'The backend notifies the client of the successful write. There is no change to the document data, but there is a metadata change because the "pending writes" flag is now ',(0,o.kt)("inlineCode",{parentName:"li"},"false"),".")),(0,o.kt)("p",null,"If you want to receive snapshot events when the document or query metadata changes, pass a listen options object when attaching your listener:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},"document.addSnapshotListener( snapshotEventHandler, MetadataChanges.INCLUDE );\n")),(0,o.kt)("h2",{id:"listen-to-multiple-documents-in-a-collection"},"Listen to multiple documents in a collection"),(0,o.kt)("p",null,"As with documents, you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"addSnapshotListener()")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"query()")," to listen to the results of a query. This creates a query snapshot. For example, to listen to the documents with state CA:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'FirebaseFirestore.service.collection("cities")\n        .whereEqualTo("state", "CA")\n        .addSnapshotListener( querySnapshotEventHandler );\n\nfunction querySnapshotEventHandler( event:QueryEvent ):void \n{\n    if (event.message != null && event.message != "") \n    {\n        trace( "Error with query: " + event.message );\n    }\n    else \n    {\n        for each (var doc:DocumentSnapshot in event.snapshot.getDocuments())\n        {\n            // ... list cities in CA\n        }\n    }\n}\n')),(0,o.kt)("p",null,"The snapshot handler will receive a new query snapshot every time the query results change (that is, when a document is added, removed, or modified)."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Important"),": As explained above under Events for local changes, you will receive events immediately for your local writes. Your listener can use the metadata.hasPendingWrites field on each document to determine whether the document has local changes that have not yet been written to the backend.")),(0,o.kt)("h2",{id:"view-changes-between-snapshots"},"View changes between snapshots"),(0,o.kt)("p",null,"It is often useful to see the actual changes to query results between query snapshots, instead of simply using the entire query snapshot. For example, you may want to maintain a cache as individual documents are added, removed, and modified."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'FirebaseFirestore.service.collection("cities")\n        .whereEqualTo("state", "CA")\n        .addSnapshotListener( querySnapshotEventHandler );\n\nfunction querySnapshotEventHandler( event:QueryEvent ):void \n{\n    if (event.message != null && event.message != "") \n    {\n        trace( "Error with query: " + event.message );\n    }\n    else \n    {\n        for each (var docChange:DocumentChange in event.snapshot.getDocumentChanges())\n        {\n            switch (docChange.changeType)\n            {\n                case DocumentChange.ADDED:\n                    // New city\n                    break;\n                case DocumentChange.MODIFIED:\n                    // Nodified city\n                    break;\n                case DocumentChange.REMOVED:\n                    // Removed city\n                    break;\n            }\n        }\n    }\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Important"),": The first query snapshot contains added events for all existing documents that match the query. This is because you're getting a set of changes that bring your query snapshot current with the initial state of the query. This allows you, for instance, to directly populate your UI from the changes you receive in the first query snapshot, without needing to add special logic for handling the initial state.")),(0,o.kt)("p",null,"The initial state can come from the server directly, or from a local cache. If there is state available in a local cache, the query snapshot will be initially populated with the cached data, then updated with the server's data when the client has caught up with the server's state."),(0,o.kt)("h2",{id:"detach-a-listener"},"Detach a listener"),(0,o.kt)("p",null,"When you are no longer interested in listening to your data, you must detach your listener so that your event callbacks stop getting called. This allows the client to stop using bandwidth to receive updates."),(0,o.kt)("p",null,"You can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"removeSnapshotListener()")," function to remove your handler and stop updates."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'FirebaseFirestore.service.collection("cities").document("SF")\n    .removeSnapshotListener( snapshotEventHandler );\n')))}p.isMDXComponent=!0}}]);