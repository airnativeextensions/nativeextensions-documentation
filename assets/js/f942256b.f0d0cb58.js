"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[78681],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var o=i(96540);const t={},r=o.createContext(t);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(r.Provider,{value:n},e.children)}},96197:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>g,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"location/geofences","title":"Geofences","description":"Authorisation","source":"@site/docs/location/geofences.md","sourceDirName":"location","slug":"/location/geofences","permalink":"/docs/location/geofences","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Geofences","sidebar_label":"Geofences"},"sidebar":"location","previous":{"title":"Location Monitoring","permalink":"/docs/location/location-monitoring"},"next":{"title":"Geocoding","permalink":"/docs/location/geocoding"}}');var t=i(74848),r=i(28453);const s={title:"Geofences",sidebar_label:"Geofences"},a=void 0,c={},d=[{value:"Authorisation",id:"authorisation",level:2},{value:"Start Monitoring a Geofence Region",id:"start-monitoring-a-geofence-region",level:2},{value:"Android",id:"android",level:3},{value:"Stop Monitoring a Geofence Region",id:"stop-monitoring-a-geofence-region",level:2},{value:"Operation Notes and Caveats",id:"operation-notes-and-caveats",level:2},{value:"iOS",id:"ios",level:3},{value:"Android",id:"android-1",level:3}];function l(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"authorisation",children:"Authorisation"}),"\n",(0,t.jsxs)(n.p,{children:["In order to use Geofences you should request the ",(0,t.jsx)(n.code,{children:"ALWAYS"})," authorisation. Apps with geofencing capabilities should use Always authorization due to the need to monitor geofences even when the app isn\u2019t running in the foreground."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally you need to have added the location ",(0,t.jsx)(n.code,{children:"UIBackgroundModes"})," on iOS."]}),"\n",(0,t.jsx)(n.h2,{id:"start-monitoring-a-geofence-region",children:"Start Monitoring a Geofence Region"}),"\n",(0,t.jsxs)(n.p,{children:["To start monitoring a region you create a ",(0,t.jsx)(n.code,{children:"Region"})," instance representing the Geofenced region.\nThis object has a location (latitude and longitude) and a radius to specify the location and size of the region, and you should also assign a region a unique identifier so you can later identify the region that was entered/exited."]}),"\n",(0,t.jsxs)(n.p,{children:["The radius represents the distance in ",(0,t.jsx)(n.strong,{children:"meters"})," from the specified location, at which the system will trigger the notification."]}),"\n",(0,t.jsxs)(n.p,{children:["Once you have defined your region you start monitoring by calling ",(0,t.jsx)(n.code,{children:"startMonitoringRegion"}),".\nYou can call this multiple times if you wish to monitor several regions."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-actionscript",children:'Location.service.geofences.addEventListener( RegionEvent.START_MONITORING, startMonitoringHandler );\nLocation.service.geofences.addEventListener( RegionEvent.ENTER, enterHandler );\nLocation.service.geofences.addEventListener( RegionEvent.EXIT, exitHandler );\n\nvar region:Region = new Region();\nregion.identifier \t= "some-unique-id";\nregion.latitude \t= 14.123456;\nregion.longitude \t= 12.345678;\nregion.radius \t\t= 100;\n\nvar success:Boolean = Location.service.geofences.startMonitoringRegion( region );\n\nfunction startMonitoringHandler( event:RegionEvent ):void\n{\n\ttrace( "start monitor: "+event.region.identifier );\n}\n\n\nfunction enterHandler( event:RegionEvent ):void\n{\n\ttrace( "region enter: "+event.region.identifier );\n}\n\nfunction exitHandler( event:RegionEvent ):void\n{\n\ttrace( "region exit: "+event.region.identifier );\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"android",children:"Android"}),"\n",(0,t.jsxs)(n.p,{children:["On Android you can trigger your application to start if it is not running by setting the ",(0,t.jsx)(n.code,{children:"startApplicationOnEnter"})," flag on the region. If you set this flag to ",(0,t.jsx)(n.code,{children:"true"})," then when the device enters the region your application will be automatically started."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-actionscript",children:"var region:Region = new Region();\nregion.startApplicationOnEnter = true;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The default is ",(0,t.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"stop-monitoring-a-geofence-region",children:"Stop Monitoring a Geofence Region"}),"\n",(0,t.jsxs)(n.p,{children:["Stopping location updates is simply a matter of calling ",(0,t.jsx)(n.code,{children:"stopMonitoringRegion"})," and passing the same ",(0,t.jsx)(n.code,{children:"Region"})," used to start monitoring the region. This will dispatch a ",(0,t.jsx)(n.code,{children:"RegionEvent.STOP_MONITORING"})," event when successful."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-actionscript",children:'Location.service.geofences.addEventListener( RegionEvent.STOP_MONITORING, stopMonitoringHandler );\n\nvar success:Boolean = Location.service.geofences.stopMonitoringRegion( region );\n\n\nfunction stopMonitoringHandler( event:RegionEvent ):void\n{\n\ttrace( "stop monitor: "+event.region.identifier );\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you have finished listening to geofences you should also remove any ",(0,t.jsx)(n.code,{children:"RegionEvent"})," listeners you may have been using."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-actionscript",children:"Location.service.geofences.removeEventListener( RegionEvent.START_MONITORING, startMonitoringHandler );\nLocation.service.geofences.removeEventListener( RegionEvent.STOP_MONITORING, stopMonitoringHandler );\nLocation.service.geofences.removeEventListener( RegionEvent.ENTER, enterHandler );\nLocation.service.geofences.removeEventListener( RegionEvent.EXIT, exitHandler );\n"})}),"\n",(0,t.jsx)(n.h2,{id:"operation-notes-and-caveats",children:"Operation Notes and Caveats"}),"\n",(0,t.jsx)(n.p,{children:"The entry and exit events are generated whenever the OS determines that a region is entered or exited. The conditions for this vary on the operating systems and can vary from a few seconds to a few minutes."}),"\n",(0,t.jsx)(n.h3,{id:"ios",children:"iOS"}),"\n",(0,t.jsx)(n.p,{children:"An app can register up to 20 regions at a time. In order to report region changes in a timely manner, the region monitoring service requires network connectivity."}),"\n",(0,t.jsx)(n.p,{children:"To work around this limit, consider registering only those regions in the user\u2019s immediate vicinity. As the user\u2019s location changes, you can remove regions that are now farther way and add regions coming up on the user\u2019s path."}),"\n",(0,t.jsx)(n.p,{children:"Regions with a radius between 1 and 400 meters work better on iPhone 4S or later devices. On these devices, an app can expect to receive the appropriate region entered or region exited notification within 3 to 5 minutes on average, if not sooner."}),"\n",(0,t.jsx)(n.p,{children:"The system doesn\u2019t report boundary crossings until the boundary plus a system-defined cushion distance is exceeded. This cushion value prevents the system from generating numerous entered and exited events in quick succession while the user is traveling close the edge of the boundary."}),"\n",(0,t.jsx)(n.h3,{id:"android-1",children:"Android"}),"\n",(0,t.jsx)(n.p,{children:"Android entry/exit events are dispatched somewhat faster than on iOS."})]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);