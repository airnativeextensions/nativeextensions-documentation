"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[78614],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),h=r,g=d["".concat(l,".").concat(h)]||d[h]||c[h]||o;return n?a.createElement(g,i(i({ref:t},u),{},{components:n})):a.createElement(g,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},25361:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return p},default:function(){return c}});var a=n(87462),r=n(63366),o=(n(67294),n(3905)),i={title:"Migration",sidebar_label:"Migration"},s=void 0,l={unversionedId:"inappbilling/migration",id:"inappbilling/migration",isDocsHomePage:!1,title:"Migration",description:"Version 12.0",source:"@site/docs/inappbilling/migration.md",sourceDirName:"inappbilling",slug:"/inappbilling/migration",permalink:"/docs/inappbilling/migration",tags:[],version:"current",frontMatter:{title:"Migration",sidebar_label:"Migration"},sidebar:"inappbilling",previous:{title:"In App Updates",permalink:"/docs/inappbilling/in-app-updates"},next:{title:"User Data",permalink:"/docs/inappbilling/user-data"}},p=[{value:"Version 12.0",id:"version-120",children:[{value:"Manifest Additions",id:"manifest-additions",children:[]},{value:"In-App Updates",id:"in-app-updates",children:[]}]},{value:"Version 8.0",id:"version-80",children:[{value:"Google Play Acknowledging Purchases",id:"google-play-acknowledging-purchases",children:[]},{value:"Google Play Pending Purchases",id:"google-play-pending-purchases",children:[]},{value:"Google Play Developer Payload",id:"google-play-developer-payload",children:[]},{value:"API changes",id:"api-changes",children:[]}]}],u={toc:p};function c(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"version-120"},"Version 12.0"),(0,o.kt)("p",null,"Version 12 implemented Google Play Billing client library v3.0"),(0,o.kt)("p",null,"This brings some breaking changes to the developer payload, which is ",(0,o.kt)("strong",{parentName:"p"},"no longer supported"),"! Any metadata that you wish to store about a purchase must now be done on a secure backend server that you maintain. You should associate this data with the purchase token (",(0,o.kt)("inlineCode",{parentName:"p"},"transactionIdentifier"),")."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"To ensure metadata is associated in the case of purchase flow interruptions, Google recommends storing the metadata on your backend server prior to launching the purchase dialog and associating it with your user\u2019s account ID, the SKU being purchased, and the current timestamp.")),(0,o.kt)("p",null,"You will still be able to retrieve developer payloads attached to purchases made with previous versions of the library."),(0,o.kt)("h3",{id:"manifest-additions"},"Manifest Additions"),(0,o.kt)("p",null,"Make sure you add the following to your ",(0,o.kt)("inlineCode",{parentName:"p"},"application")," node in your android manifest additions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},'<meta-data android:name="com.google.android.play.billingclient.version" android:value="3.0.0" />\n')),(0,o.kt)("p",null,"Check ",(0,o.kt)("a",{parentName:"p",href:"add-the-extension"},"Add the Extension")," for more information."),(0,o.kt)("h3",{id:"in-app-updates"},"In-App Updates"),(0,o.kt)("p",null,"If you are looking to add In-App Updates make sure you add the additional extensions and manifest additions as outlined in the ",(0,o.kt)("a",{parentName:"p",href:"in-app-updates#additional-requirements"},"documentation")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"version-80"},"Version 8.0"),(0,o.kt)("p",null,"Version 8 implements the pending purchases and acknowledgement functionality for Google Play Billing that has been recently added, along with the re-implementation of the developer payload."),(0,o.kt)("h3",{id:"google-play-acknowledging-purchases"},"Google Play Acknowledging Purchases"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Google Play supports purchasing products from inside of your app (in-app) or outside of your app (out-of-app). In order for Google Play to ensure a consistent purchase experience regardless of where the user purchases your product, you must acknowledge all purchases received through the Google Play Billing Library as soon as possible after granting entitlement to the user. If you do not acknowledge a purchase within three days, the user automatically receives a refund, and Google Play revokes the purchase. ")),(0,o.kt)("p",null,"Purchases that have been completed but not yet acknowledged will be placed into a pending state and be available through the ",(0,o.kt)("inlineCode",{parentName:"p"},"getPendingPurchases()")," method."),(0,o.kt)("p",null,"In order to acknowledge that the purchase has been delivered to the user you call ",(0,o.kt)("inlineCode",{parentName:"p"},"finishPurchase()")," on any purchases that are pending. We have implemented the acknowledge call in the ",(0,o.kt)("inlineCode",{parentName:"p"},"finishPurchase()")," method as this should closely resemble the process of how you finish a purchase on iOS. "),(0,o.kt)("p",null,"These purchases will now be returned by the ",(0,o.kt)("inlineCode",{parentName:"p"},"getPendingPurchases()")," method ",(0,o.kt)("strong",{parentName:"p"},"as well as the ",(0,o.kt)("inlineCode",{parentName:"strong"},"getPurchases()")," method"),"."),(0,o.kt)("p",null,"If you have an iOS version of your application already finishing purchases then that logic should remain the same."),(0,o.kt)("h3",{id:"google-play-pending-purchases"},"Google Play Pending Purchases"),(0,o.kt)("p",null,'Android\'s "Pending Purchases" are slightly different from the concept on iOS. On Android pending purchases are purchases that ',(0,o.kt)("strong",{parentName:"p"},"have not yet been made")," and have only been initiated, whereas on iOS pending purchases are completed awaiting the developer confirmation (i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"finishPurchase()")," call)."),(0,o.kt)("p",null,"Google Play Billing uses this concept as a deferred payment state."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"For example, a user might choose to purchase your in-app product at a physical store using cash. This means that the transaction is completed outside of your app. In this scenario, you should grant entitlement only after the user has completed the transaction."),(0,o.kt)("p",{parentName:"blockquote"},"For pending transactions (new in version 2.0), the three-day window (for acknowleding the purchase) starts when the purchase has moved to the SUCCESS state and does not apply while the purchase is in a PENDING state.")),(0,o.kt)("p",null,"To better match the concepts across Apple's In App Purchases and Google Play Billing, we represent Android Pending Purchases as Deferred Purchases, ie. a purchase will have the state ",(0,o.kt)("inlineCode",{parentName:"p"},"STATE_DEFERRED"),". "),(0,o.kt)("p",null,"A deferred purchase means that it has been initiated and is awaiting a further process before it can continue, eg parental approval. We believe this closely matches the Android concept and the logic implemented in your application should already handle this case. The deferred state is really just informing you that the purchase UI process has completed with the user selecting a method that will complete at a later time."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: Android Pending Purchases are not returned through the ",(0,o.kt)("inlineCode",{parentName:"p"},"getPendingPurchases()")," call. Instead you should call ",(0,o.kt)("inlineCode",{parentName:"p"},"getPurchases()")," and check for any purchases in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Purchase.STATE_DEFERRED")," state.")),(0,o.kt)("p",null,"You may need to update any logic that delivers products through the ",(0,o.kt)("inlineCode",{parentName:"p"},"getPurchases()")," call. Previously you could have assumed that every purchase returned through ",(0,o.kt)("inlineCode",{parentName:"p"},"getPurchases()")," was a product available to the user. You should now ensure you check the state of the purchase is ",(0,o.kt)("inlineCode",{parentName:"p"},"STATE_PURCHASED")," before delivering a product:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},"if (InAppBilling.service.isGetPurchasesSupported)\n{\n    InAppBilling.service.addEventListener( PurchaseEvent.GET_PURCHASES_COMPLETE, getPurchasesCompleteHandler );\n    InAppBilling.service.addEventListener( PurchaseEvent.GET_PURCHASES_FAILED, getPurchasesFailedHandler );\n    \n    var success:Boolean = InAppBilling.service.getPurchases();\n}\n\n\nfunction getPurchasesCompleteHandler( event:PurchaseEvent ):void \n{\n    for each (var purchase:Purchase in event.data)\n    {\n        // Check the purchase state\n        if (purchase.transactionState == Purchase.STATE_PURCHASED)\n        {\n            //  Deliver product to user\n        }\n    }\n}\n")),(0,o.kt)("h3",{id:"google-play-developer-payload"},"Google Play Developer Payload"),(0,o.kt)("p",null,"The developer payload has been re-introduced in this version however it is different from using it in the past. It is now only attached when you acknowledge a purchase, rather than when it is initiated. "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You can attach a developer payload parameter to a purchase, but only when the purchase is acknowledged or consumed. This is unlike developer payload in the past, where the payload could be specified when launching the purchase flow. Because purchases can now be initiated from outside of your app, this change ensures that you always have an opportunity to add a payload to purchases.")),(0,o.kt)("p",null,"So to attach a developer payload you need to set the payload on a purchase when calling ",(0,o.kt)("inlineCode",{parentName:"p"},"finishPurchase()"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'purchase.developerPayload = "some_payload";\n\nInAppBilling.service.finishPurchase( purchase );\n')),(0,o.kt)("p",null,"This payload will now be returned in ",(0,o.kt)("inlineCode",{parentName:"p"},"getPurchases()")," and other purchase related events."),(0,o.kt)("h3",{id:"api-changes"},"API changes"),(0,o.kt)("p",null,"We have changed the signature of the consume purchase API to better match other parts of the API. It now takes a ",(0,o.kt)("inlineCode",{parentName:"p"},"Purchase")," parameter rather than the ",(0,o.kt)("inlineCode",{parentName:"p"},"PurchaseRequest"),"."),(0,o.kt)("p",null,"This should be a simple change. Existing code using a request:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},"var request:PurchaseRequest = var request:PurchaseRequest = new PurchaseRequest()\n                        .setProductId( purchase.productId );\n\nvar success:Boolean = InAppBilling.service.consumePurchase( request );\n")),(0,o.kt)("p",null,"becomes:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},"var success:Boolean = InAppBilling.service.consumePurchase( purchase );\n")),(0,o.kt)("p",null,"or if you don't have a reference to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Purchase")," you can just use the product id: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},"var success:Boolean = InAppBilling.service.consumePurchaseByProductId( productId );\n")))}c.isMDXComponent=!0}}]);