"use strict";(self.webpackChunknativeextensions_documentation=self.webpackChunknativeextensions_documentation||[]).push([[49830],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),o=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=o(e.components);return a.createElement(i.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),c=o(t),h=r,g=c["".concat(i,".").concat(h)]||c[h]||d[h]||l;return t?a.createElement(g,s(s({ref:n},p),{},{components:t})):a.createElement(g,s({ref:n},p))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,s=new Array(l);s[0]=h;var u={};for(var i in n)hasOwnProperty.call(n,i)&&(u[i]=n[i]);u.originalType=e,u[c]="string"==typeof e?e:r,s[1]=u;for(var o=2;o<l;o++)s[o]=t[o];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>s});var a=t(67294),r=t(86010);const l={tabItem:"tabItem_Ymn6"};function s(e){let{children:n,hidden:t,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(l.tabItem,s),hidden:t},n)}},74866:(e,n,t)=>{t.d(n,{Z:()=>P});var a=t(87462),r=t(67294),l=t(86010),s=t(12466),u=t(16550),i=t(91980),o=t(67392),p=t(50012);function c(e){return function(e){var n,t;return null!=(n=null==(t=r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}function d(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=null!=n?n:c(t);return function(e){const n=(0,o.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:t}=e;const a=(0,u.k6)(),l=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,i._X)(l),(0,r.useCallback)((e=>{if(!l)return;const n=new URLSearchParams(a.location.search);n.set(l,e),a.replace({...a.location,search:n.toString()})}),[l,a])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,l=d(e),[s,u]=(0,r.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const r=null!=(n=a.find((e=>e.default)))?n:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:l}))),[i,o]=g({queryString:t,groupId:a}),[c,f]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[a,l]=(0,p.Nk)(t);return[a,(0,r.useCallback)((e=>{t&&l.set(e)}),[t,l])]}({groupId:a}),m=(()=>{const e=null!=i?i:c;return h({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{m&&u(m)}),[m]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:l}))throw new Error("Can't select invalid tab value="+e);u(e),o(e),f(e)}),[o,f,l]),tabValues:l}}var m=t(72389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function v(e){let{className:n,block:t,selectedValue:u,selectValue:i,tabValues:o}=e;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.o5)(),d=e=>{const n=e.currentTarget,t=p.indexOf(n),a=o[t].value;a!==u&&(c(n),i(a))},h=e=>{var n;let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var a;const n=p.indexOf(e.currentTarget)+1;t=null!=(a=p[n])?a:p[0];break}case"ArrowLeft":{var r;const n=p.indexOf(e.currentTarget)-1;t=null!=(r=p[n])?r:p[p.length-1];break}}null==(n=t)||n.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":t},n)},o.map((e=>{let{value:n,label:t,attributes:s}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:u===n?0:-1,"aria-selected":u===n,key:n,ref:e=>p.push(e),onKeyDown:h,onClick:d},s,{className:(0,l.Z)("tabs__item",y.tabItem,null==s?void 0:s.className,{"tabs__item--active":u===n})}),null!=t?t:n)})))}function b(e){let{lazy:n,children:t,selectedValue:a}=e;const l=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=l.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function k(e){const n=f(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",y.tabList)},r.createElement(v,(0,a.Z)({},e,n)),r.createElement(b,(0,a.Z)({},e,n)))}function P(e){const n=(0,m.Z)();return r.createElement(k,(0,a.Z)({key:String(n)},e))}},65930:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>g,frontMatter:()=>u,metadata:()=>o,toc:()=>c});var a=t(87462),r=(t(67294),t(3905)),l=t(74866),s=t(85162);const u={title:"Pending Purchases",sidebar_label:"Pending Purchases"},i=void 0,o={unversionedId:"inappbilling/pending-purchases",id:"inappbilling/pending-purchases",title:"Pending Purchases",description:"Interupted / Pending / Acknowledging Purchases",source:"@site/docs/inappbilling/pending-purchases.mdx",sourceDirName:"inappbilling",slug:"/inappbilling/pending-purchases",permalink:"/docs/inappbilling/pending-purchases",draft:!1,tags:[],version:"current",frontMatter:{title:"Pending Purchases",sidebar_label:"Pending Purchases"},sidebar:"inappbilling",previous:{title:"Make a Purchase",permalink:"/docs/inappbilling/make-a-purchase"},next:{title:"Restore Purchases",permalink:"/docs/inappbilling/restore-purchases"}},p={},c=[{value:"Get Pending Purchases",id:"get-pending-purchases",level:2},{value:"Setup",id:"setup",level:2},{value:"Google Play Billing Acknowledgement",id:"google-play-billing-acknowledgement",level:2}],d={toc:c},h="wrapper";function g(e){let{components:n,...t}=e;return(0,r.kt)(h,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Interupted / Pending / Acknowledging Purchases")),(0,r.kt)("p",null,"Pending purchases are purchases that are currently still in progress and you are yet to deliver the appropriate product and finish the purchase."),(0,r.kt)("p",null,"Pending purchases may occur when a purchase is interupted, for example, the user left the application during a purchase, or they were initiated from an external source."),(0,r.kt)("p",null,"Purchases will remain in the pending purchases queue until you finish the purchase. "),(0,r.kt)("p",null,"The main reason for this process is to allow you to verify the transaction with your server before delivering the product to your user and informing the billing service that the purchase has been delivered to the user."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"From version 8, this process is applicable to Apple's In-App Purchases, Google Play Billing and Amazon In-App Purchases!"),"\nThe process continues to work across all services and platforms.")),(0,r.kt)("p",null,"The services use slightly different terminology in their documentation you may need to be aware of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Apple uses "pending";'),(0,r.kt)("li",{parentName:"ul"},'Google uses "acknowledged", i.e. an un-acknowledged purchase is a pending purchase, ',(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},'when we finish a purchase we "acknowledge" the purchase;'))),(0,r.kt)("li",{parentName:"ul"},'Amazon uses "fulfilled", i.e. an un-fulfillled purchase is a pending purchase, ',(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},'when we finish a purchase we "notify of fulfillment" of the purchase;')))),(0,r.kt)("h2",{id:"get-pending-purchases"},"Get Pending Purchases"),(0,r.kt)("p",null,"You can retrieve the list of pending purchases by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"getPendingPurchases()")," function.\nThis will return the array of ",(0,r.kt)("inlineCode",{parentName:"p"},"Purchase")," objects that are currently 'pending'."),(0,r.kt)(l.Z,{groupId:"framework",defaultValue:"air",values:[{label:"AIR",value:"air"},{label:"Unity",value:"unity"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"air",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-actionscript"},"// Check for any pending purchases\nvar pendingPurchases:Array = InAppBilling.service.getPendingPurchases();\nfor each (var p:Purchase in pendingPurchases)\n{\n    // You should process any pending purchases here and then finish if necessary\n    processPurchase( p );\n}\n"))),(0,r.kt)(s.Z,{value:"unity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// Check for any pending purchases\nList<Purchase> pendingPurchases = InAppBilling.Instance.GetPendingPurchases();\nforeach (Purchase p in pendingPurchases)\n{\n    // You should process any pending purchases here and then finish if necessary\n    ProcessPurchase( p );\n}\n")))),(0,r.kt)("h2",{id:"setup"},"Setup"),(0,r.kt)("p",null,"The pending purchases queue may not be initialised immediately, so you may find that in your setup success event handler that the pending purchases queue is empty even though there are pending purchases."),(0,r.kt)("p",null,"The queue can be updated just after setup has completed which will be indicated by the normal purchases updated event.\nThis is particularly true on iOS/tvOS where the payment queue update (which populates the pending purchases) will occur\na short time after setup succeeds."),(0,r.kt)(l.Z,{groupId:"framework",defaultValue:"air",values:[{label:"AIR",value:"air"},{label:"Unity",value:"unity"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"air",mdxType:"TabItem"},(0,r.kt)("p",null,"We suggest you add event listeners for the ",(0,r.kt)("inlineCode",{parentName:"p"},"PurchaseEvent.PURCHASES_UPDATED")," event before you call ",(0,r.kt)("inlineCode",{parentName:"p"},"setup()"),"\nto make sure you process all pending notifications at startup. "),(0,r.kt)("p",null,"You should also perform a check of the pending purchcases in your ",(0,r.kt)("inlineCode",{parentName:"p"},"InAppBillingEvent.SETUP_SUCCESS")," handler. "),(0,r.kt)("p",null,"Purchases that are already available at startup may not trigger a purchases updated event so you must handling purchases in both cases."),(0,r.kt)("p",null,"For example: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-actionscript"},"// Add purchases updated handler\nInAppBilling.service.addEventListener( PurchaseEvent.PURCHASES_UPDATED, purchases_updatedHandler );\n\nInAppBilling.service.addEventListener( InAppBillingEvent.SETUP_SUCCESS, setup_successHandler );\nInAppBilling.service.addEventListener( InAppBillingEvent.SETUP_FAILURE, setup_failureHandler );\n\nInAppBilling.service.setup(\n        new BillingService()\n                .setGooglePlayPublicKey( GOOGLE_PLAY_INAPP_BILLING_KEY )\n);\n\nfunction setup_successHandler( event:InAppBillingEvent ):void \n{\n    // Check for pending purchases that are already available\n    for each (var p:Purchase in InAppBilling.service.getPendingPurchases())\n    {\n        processPurchase( p );\n    }\n}\n\nfunction purchases_updatedHandler( event:PurchaseEvent ):void \n{\n    // Your standard purchase queue handler\n\n    for each (var purchase:Purchase in event.data)\n    {\n        processPurchase( p );\n    }\n}\n")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Do not rely on the ",(0,r.kt)("inlineCode",{parentName:"p"},"PurchaseEvent.PURCHASES_UPDATED")," event as part of your flow.\nThis event may not be dispatched if there aren't any pending purchases, or if they are available in the setup success handler."))),(0,r.kt)(s.Z,{value:"unity",mdxType:"TabItem"},(0,r.kt)("p",null,"We suggest you add event listeners for the ",(0,r.kt)("inlineCode",{parentName:"p"},"OnPurchasesUpdated")," event before you call ",(0,r.kt)("inlineCode",{parentName:"p"},"Setup()"),"\nto make sure you process all pending notifications at startup. "),(0,r.kt)("p",null,"You should also perform a check of the pending purchcases in your setup success handler. "),(0,r.kt)("p",null,"Purchases that are already available at startup may not trigger a purchases updated event so you must handling purchases in both cases."),(0,r.kt)("p",null,"For example: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// Add purchases updated handler\nInAppBilling.Instance.Events.OnPurchasesUpdated += PurchasesUpdatedHandler;\n\nInAppBilling.Instance.Setup(\n        new BillingService(),\n        (e) =>\n        {\n            if (e.type == InAppBillingEvent.SETUP_SUCCESS)\n            {\n                // Check for pending purchases that are already available\n                foreach (Purchase p in InAppBilling.Instance.GetPendingPurchases())\n                {\n                    ProcessPurchase( p );\n                }\n            }\n        }\n);\n\nprivate void PurchasesUpdatedHandler(PurchaseEvent e)\n{\n    // Your standard purchase queue handler\n    foreach (Purchase purchase in e.purchases)\n    {\n        ProcessPurchase( purchase );\n    }\n}\n")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Do not rely on the ",(0,r.kt)("inlineCode",{parentName:"p"},"OnPurchasesUpdated")," event as part of your flow.\nThis event may not be dispatched if there aren't any pending purchases, or if they are available in the setup success handler.")))),(0,r.kt)("h2",{id:"google-play-billing-acknowledgement"},"Google Play Billing Acknowledgement"),(0,r.kt)("p",null,"With Google Play Billing finishing a purchase performs the acknowledgement of the purchase."),(0,r.kt)("p",null,"It is very important to note that if you don't acknowledge a purchase (i.e. call finish purchase) it will be refunded."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Google Play supports purchasing products from inside of your app (in-app) or outside of your app (out-of-app). In order for Google Play to ensure a consistent purchase experience regardless of where the user purchases your product, you must acknowledge all purchases received through the Google Play Billing Library as soon as possible after granting entitlement to the user. If you do not acknowledge a purchase within three days, the user automatically receives a refund, and Google Play revokes the purchase. ")))}g.isMDXComponent=!0}}]);